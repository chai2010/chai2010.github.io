<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>用Go语言开发Web程序[翻译] - chai2010 的博客</title>
  <link rel="alternate" hreflang="zh-CN" href="https://chai2010.cn/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="chai2010" />
  <meta name="description" content="英文: http://golang.org/doc/articles/wiki/ 简介 本教程将讨论： 创建一个支持加载和保存的数据结构 使用 net/http 包来构建web应用程序 使用 html/template 包来处理HTML模板 使用 regexp 包来验证用户输入 使用闭" />

  <meta name="keywords" content="chai2010, Go, Golang" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="https://chai2010.cn/post/golang/goweb2013/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">


<meta property="og:title" content="用Go语言开发Web程序[翻译]" />
<meta property="og:description" content="英文: http://golang.org/doc/articles/wiki/ 简介 本教程将讨论： 创建一个支持加载和保存的数据结构 使用 net/http 包来构建web应用程序 使用 html/template 包来处理HTML模板 使用 regexp 包来验证用户输入 使用闭" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chai2010.cn/post/golang/goweb2013/" />



<meta property="article:published_time" content="2013-04-06T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2013-04-06T00:00:00&#43;00:00"/>











<meta itemprop="name" content="用Go语言开发Web程序[翻译]">
<meta itemprop="description" content="英文: http://golang.org/doc/articles/wiki/ 简介 本教程将讨论： 创建一个支持加载和保存的数据结构 使用 net/http 包来构建web应用程序 使用 html/template 包来处理HTML模板 使用 regexp 包来验证用户输入 使用闭">


<meta itemprop="datePublished" content="2013-04-06T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2013-04-06T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6608">



<meta itemprop="keywords" content="golang,web," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="用Go语言开发Web程序[翻译]"/>
<meta name="twitter:description" content="英文: http://golang.org/doc/articles/wiki/ 简介 本教程将讨论： 创建一个支持加载和保存的数据结构 使用 net/http 包来构建web应用程序 使用 html/template 包来处理HTML模板 使用 regexp 包来验证用户输入 使用闭"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-621845-14', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">chai2010 的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/talks/">
        <li class="mobile-menu-item">报告</li>
      </a><a href="/books/">
        <li class="mobile-menu-item">图书</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">chai2010 的博客</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/talks/">报告</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/books/">图书</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">用Go语言开发Web程序[翻译]</h1>

      <div class="post-meta">
        <span class="post-time"> 2013-04-06 </span>
        <div class="post-category">
            
              <a href="/categories/golang/"> golang </a>
            
          </div>
        <span class="more-meta"> 约 6608 字 </span>
        <span class="more-meta"> 预计阅读 14 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#开始">开始</a></li>
<li><a href="#数据结构">数据结构</a></li>
<li><a href="#了解net-http包-插曲">了解net/http包（插曲）</a></li>
<li><a href="#基于net-http包提供wiki页面">基于net/http包提供wiki页面</a></li>
<li><a href="#编辑页面">编辑页面</a></li>
<li><a href="#使用html-template包">使用html/template包</a></li>
<li><a href="#处理不存在的页面">处理不存在的页面</a></li>
<li><a href="#保存页面">保存页面</a></li>
<li><a href="#错误处理">错误处理</a></li>
<li><a href="#缓存模板">缓存模板</a></li>
<li><a href="#验证">验证</a></li>
<li><a href="#函数字面值和闭包">函数字面值和闭包</a></li>
<li><a href="#看看页面效果">看看页面效果!</a></li>
<li><a href="#其他任务">其他任务</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<!-- 标题: Go语言编写Web程序 -->

<!-- 翻译: chaishushan{AT}gmail.com -->

<!-- 原文: http://golang.org/doc/articles/wiki/ -->

<ul>
<li>英文: <a href="http://golang.org/doc/articles/wiki/">http://golang.org/doc/articles/wiki/</a></li>
</ul>

<h2 id="简介">简介</h2>

<p>本教程将讨论：</p>

<ul>
<li>创建一个支持加载和保存的数据结构</li>
<li>使用 net/http 包来构建web应用程序</li>
<li>使用 html/template 包来处理HTML模板</li>
<li>使用 regexp 包来验证用户输入</li>
<li>使用闭包</li>
</ul>

<p>基本知识：</p>

<ul>
<li>有一定的编程经验</li>
<li>了解基本的web技术(HTTP、HTML)</li>
<li>一些UNIX/DOS命令行知识</li>
</ul>

<h2 id="开始">开始</h2>

<p>目前、你需要一个运行FreeBSD、Linux、OS X 或 Windows的机器。 我们将使用 $ 来代表命令提示符。</p>

<p>安装Go语言环境（参考 安装说明）。</p>

<p>为本教程新建一个目录，将新建目录添加到GOPATH环境变量，然后命令行切换到新建目录:</p>

<pre><code>$ mkdir gowiki
$ cd gowiki
</code></pre>

<p>创建一个名为wiki.go的源文件，使用你喜欢的编辑器打开，并添加以下代码：</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
)
</code></pre>

<p>我们从标准库导入了fmt和ioutil包。 后面我们将实现更多的功能，到时候我们会添加更多的包到import声明。</p>

<h2 id="数据结构">数据结构</h2>

<p>我们现定义数据结构。一个wiki通常有一些列相互关联的页面组成，每个页面有一个标题和一个主体（页面的内容）。 在这里，我们定的Page结构体包含标题和主体两个成员。</p>

<pre><code>type Page struct {
    Title string
    Body  []byte
}
</code></pre>

<p>类型 <code>[]byte</code> 表示“一个byte切片”。 （参见 Go切片：用法和本质） 我们将Body成员定义为 <code>[]byte</code> 而不是 <code>string</code> 类型， 因为我们希望类型和 <code>io</code> 库很好的配合，在后面会看到。</p>

<p>Page描述的页面内容只是保存在内存中。但是如何进行持久存储呢？ 我们可以为Page类型创建一个save方法：</p>

<pre><code>func (p *Page) save() error {
    filename := p.Title + &quot;.txt&quot;
    return ioutil.WriteFile(filename, p.Body, 0600)
}
</code></pre>

<p>方法的签名这样读：“这是一个方法，名字叫save， 方法的接收者p是一个指向Page类型结构体的指针。 方法没有参数，但有一个error类型的返回值。”</p>

<p>该方法会将Page的Body成员的值保存到一个文本文件。 为了简化，我们使用Title成员的值作为文件的名字。</p>

<p>save方法返回的error值和WriteFile函数的返回类型 一致（将byte切片写入文件的标准库函数）。程序可以通过save方法返回的 error值判断写文件时是否遇到错误。如果写文件一切正常，Page.save() 将返回nil（对应指针、接口等类型的零值）。</p>

<p>传递给WriteFile函数的第三个参数0600是一个八进制整数面值， 表示新创建的文件只对当前用户是读写权限。（更多信息请参考Unix手册 open(2)）</p>

<p>除了保存页面，我们还需要加载页面：</p>

<pre><code>func loadPage(title string) *Page {
    filename := title + &quot;.txt&quot;
    body, _ := ioutil.ReadFile(filename)
    return &amp;Page{Title: title, Body: body}
}
</code></pre>

<p>函数loadPage从title参数构造文件名，然后读取文件的内容到 新的变量body，最后返回两个值：一个指向由title和body构造的 Page面值并且错误返回值为nil。</p>

<p>函数可以返回多个值。标准库函数io.ReadFile返回[]byte和error。 在loadPage函数中，错误信息被丢失了；“空白标识符”所代表的下划线（_） 符号用于扔掉错误返回值（本质上没哟分配任何值）。</p>

<p>但是如果ReadFile遇到错误怎么办？对于这个例子，文件可能还不存在。我们不能忽略 类似的错误。我们修改函数返回*Page和error。</p>

<pre><code>func loadPage(title string) (*Page, error) {
    filename := title + &quot;.txt&quot;
    body, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }
    return &amp;Page{Title: title, Body: body}, nil
}
</code></pre>

<p>这个函数的调用者可以检测第二个返回参数；如果是nil表示成功加载页面。否则， error可以被调用者截获（更多信息请参考语言规范）。</p>

<p>现在我们有了一个简单的数据结构，并且可以保存到文件和从文件加载页面。让我们写一个main 来测试一下：</p>

<pre><code>func main() {
    p1 := &amp;Page{Title: &quot;TestPage&quot;, Body: []byte(&quot;This is a sample Page.&quot;)}
    p1.save()
    p2, _ := loadPage(&quot;TestPage&quot;)
    fmt.Println(string(p2.Body))
}
</code></pre>

<p>在编译并运行程序后，会创建一个名为TestPage.txt的文件，内容是p1 包含的页面主体。然后文件的内容被读取到p2，并且打印其Body成员到屏幕。</p>

<p>可以这样编译和运行程序：</p>

<pre><code>$ go build wiki.go
$ ./wiki
This is a sample page.
</code></pre>

<p>（如果是使用Windows系统则不需要“wiki”前面的“./”。）</p>

<p>点击这里浏览完整代码。</p>

<h2 id="了解net-http包-插曲">了解net/http包（插曲）</h2>

<p>这里是一个简要Web服务器的完整代码：</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hi there, I love %s!&quot;, r.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, handler)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<p>main函数开始调用<code>http.HandleFunc</code>，告诉<code>http</code>包用<code>handler</code>函数处理所以针对跟目录的访问请求（&rdquo;/&ldquo;）。</p>

<p>然后调用<code>http.ListenAndServe</code>，指定监听端口为8080（&rdquo;:8080&rdquo;）。 （目前先忽略第二个参数nil。）这个函数会阻塞直到程序终止。</p>

<p>函数handler的类型是http.HandlerFunc。它的参数是 一个<code>http.ResponseWriter</code>和一个<code>http.Request</code>。</p>

<p>参数<code>http.ResponseWriter</code>汇总HTTP服务器的响应；向它写入的数据会发送 到HTTP客服端。</p>

<p>参数http.Request是客户端请求数据对应的数据结构。 <code>r.URL.Path</code>表示客户端请求的URL地址。后面的<code>[1:]</code>含义是 “从Path的第一个字符到 末尾创建一个子切片。” 这样可以忽略URL路径中的开始的“/”字符。</p>

<p>如果你运行程序并访问一些URL地址：</p>

<pre><code>http://localhost:8080/monkeys
</code></pre>

<p>程序会返回一个包含以下内容的页面：</p>

<pre><code>Hi there, I love monkeys!
</code></pre>

<h2 id="基于net-http包提供wiki页面">基于net/http包提供wiki页面</h2>

<p>使用前需要导入net/http包：</p>

<pre><code>import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;io/ioutil&quot;
)
</code></pre>

<p>然后我们创建一个viewHandler函数，用于处理浏览wiki页面。它会处理所有以&rdquo;/view/&ldquo;为前缀的URL地址。</p>

<pre><code>const lenPath = len(&quot;/view/&quot;)
func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    p, _ := loadPage(title)
    fmt.Fprintf(w, &quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;, p.Title, p.Body)
}
</code></pre>

<p>首先，该函数从r.URL.Path中取出要浏览页面的标题。 全局常量lenPath是URL前缀&rdquo;/view/&ldquo;的长度。 Path的切片<code>[lenPath:]</code>用于忽略前面的6个字符。 这是因为URL地址是以&rdquo;/view/&ldquo;为前缀，它们不是页面标题的组成部分。</p>

<p>接着加载页面数据，然后格式化为一个简单的HTML页面，写入到<code>http.ResponseWriter</code>类型的w参数。</p>

<p>这里又一次使用了<code>_</code>来忽略loadPage返回的错误<code>error</code>。 这里只是为了简化代码，它并不是好的编程实践。稍后我们会继续完善这个部分。</p>

<p>要使用这个函数，我们需要修改main函数中的http初始化代码， 使用<code>viewHandler</code>函数处理对应/view/地址的请求。</p>

<pre><code>func main() {
    http.HandleFunc(&quot;/view/&quot;, viewHandler)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<p>点击这里浏览完整代码。</p>

<p>我们创建一些测试页面（例如test.txt），然后尝试提供一个wiki页面：</p>

<p>使用编辑器打开test.txt文件，输入“Hello world”内容并保存（忽略双引号）。</p>

<pre><code>$ go build wiki.go
$ ./wiki
</code></pre>

<p>如果是使用Windows系统则不需要“wiki”前面的“./”。</p>

<p>启动web服务器后，浏览<a href="http://localhost:8080/view/test">http://localhost:8080/view/test</a> 将显示一个标题为“test”内容为“Hello world”的页面。</p>

<h2 id="编辑页面">编辑页面</h2>

<p>没有编辑能力的wiki就不是真正的wiki了。我们继续创建了两个函数： 一个editHandler用于显示编辑页面的界面，另一个saveHandler 用于保存编辑后的页面内容。</p>

<p>我们先将它们加入到<code>main()</code>函数：</p>

<pre><code>func main() {
    http.HandleFunc(&quot;/view/&quot;, viewHandler)
    http.HandleFunc(&quot;/edit/&quot;, editHandler)
    http.HandleFunc(&quot;/save/&quot;, saveHandler)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<p>函数editHandler加载页面，然后显示一个HTML编辑页面。</p>

<pre><code>func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    fmt.Fprintf(w, &quot;&lt;h1&gt;Editing %s&lt;/h1&gt;&quot;+
        &quot;&lt;form action=\&quot;/save/%s\&quot; method=\&quot;POST\&quot;&gt;&quot;+
        &quot;&lt;textarea name=\&quot;body\&quot;&gt;%s&lt;/textarea&gt;&lt;br&gt;&quot;+
        &quot;&lt;input type=\&quot;submit\&quot; value=\&quot;Save\&quot;&gt;&quot;+
        &quot;&lt;/form&gt;&quot;,
        p.Title, p.Title, p.Body)
}
</code></pre>

<p>这个函数只是可工作，但是那些HTML相关的代码比较丑陋。 当然，还有更好的实现方式。</p>

<h2 id="使用html-template包">使用html/template包</h2>

<p>html/template是标准库中的包。我们使用html/template 包可以将HTML代码分离到一个文件，然后我们可以在不改变底层代码前提下调整和完善编辑页面。</p>

<p>首先，我们导入html/template包。现在我们已经不再使用fmt包了， 因此需要删除它。</p>

<pre><code>import (
    &quot;html/template&quot;
    &quot;http&quot;
    &quot;io/ioutil&quot;
    &quot;os&quot;
)
</code></pre>

<p>我们需要为编辑页面创建一个模板文件。新建edit.html文件， 并输入以下内容：</p>

<pre><code>&lt;h1&gt;Editing {{.Title}}&lt;/h1&gt;

&lt;form action=&quot;/save/{{.Title}}&quot; method=&quot;POST&quot;&gt;
&lt;div&gt;&lt;textarea name=&quot;body&quot; rows=&quot;20&quot; cols=&quot;80&quot;&gt;{{printf &quot;%s&quot; .Body}}&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre>

<p>修改editHandler函数，使用模板代替硬编码HTML：</p>

<pre><code>func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    t, _ := template.ParseFiles(&quot;edit.html&quot;)
    t.Execute(w, p)
}
</code></pre>

<p>函数<code>template.ParseFiles</code>将读取edit.html目标文件， 返回值为<code>*template.Template</code>。</p>

<p>函数<code>t.Execute</code>处理模板，将生成的HTML写入到<code>http.ResponseWriter</code>。 其中以点开头的<code>.Title</code>和<code>.Body</code>标识符将被<code>p.Title</code>和<code>p.Body</code>替换。</p>

<p>模板的驱动语句是被双花括弧包括的部分. <code>printf &quot;%s&quot; .Body</code>表示将<code>.Body</code>输出位字符串
而不是字节串, 类似<code>fmt.Printf</code>函数的效果. <code>html/template</code>可以保证输出有效的HTML字符串,
对于<code>(&gt;)</code>之类的特殊符号会自动替换为<code>&amp;gt;</code>等对应编码, 保证不会破坏原先的HTML结构.</p>

<p>需要注意的是我们移除了<code>fmt.Fprintf</code>语句, 因此也移除了<code>&quot;fmt&quot;</code>包的导入语句.</p>

<p>现在我们已经是基于模板方式的, 可以针对<code>viewHandler</code>函数创建一个名为view.html的模板文件:</p>

<pre><code>&lt;h1&gt;{{.Title}}&lt;/h1&gt;

&lt;p&gt;[&lt;a href=&quot;/edit/{{.Title}}&quot;&gt;edit&lt;/a&gt;]&lt;/p&gt;

&lt;div&gt;{{printf &quot;%s&quot; .Body}}&lt;/div&gt;
</code></pre>

<p>也要调整<code>viewHandler</code>函数:</p>

<pre><code>func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    p, _ := loadPage(title)
    t, _ := template.ParseFiles(&quot;view.html&quot;)
    t.Execute(w, p)
}
</code></pre>

<p>观察可以发现前面是否模板的方式非常相似. 因此我们将模板独立大一个函数:</p>

<pre><code>func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    p, _ := loadPage(title)
    renderTemplate(w, &quot;view&quot;, p)
}

func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    renderTemplate(w, &quot;edit&quot;, p)
}

func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    t, _ := template.ParseFiles(tmpl + &quot;.html&quot;)
    t.Execute(w, p)
}
</code></pre>

<p>现在的处理函数更加清晰简短.</p>

<h2 id="处理不存在的页面">处理不存在的页面</h2>

<p>如果访问<code>/view/APageThatDoesntExist</code>会发生什么情况? 程序会崩溃掉.
这是因为程序忽略了<code>loadPage</code>返回的错误信息. 为了处理页面不存在的情况,
程序会重定向到一个新页面的编辑页面:</p>

<pre><code>func viewHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)
        return
    }
    renderTemplate(w, &quot;view&quot;, p)
}
</code></pre>

<p><code>http.Redirect</code>函数会添加<code>http.StatusFound (302)</code>状态, 并且重新定位.</p>

<h2 id="保存页面">保存页面</h2>

<p>函数<code>saveHandler</code>用于处理提交的表单.</p>

<pre><code>func saveHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[lenPath:]
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    p.save()
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>

<p>页面的标题(URL提供)和表单的内容将作为一个新页面保存.
调用<code>save()</code>方法将页面写到文件, 然后重定向到<code>/view/</code>页面.</p>

<p><code>FormValue</code>方法返回的返回值是字符串类型. 我们需要先转换为<code>[]byte</code>, 然后填充到<code>Page</code>
结构体. 我们通过<code>[]byte(body)</code>语句做强制转换.</p>

<h2 id="错误处理">错误处理</h2>

<p>前面的代码基本都是忽略了错误处理. 这不是好的处理方式, 因为发生错误的话会导致程序崩溃.
好的处理方式是截获错误, 并给用户显示错误相关的信息. 这样即使发生错误, 服务器也
可以正常运行, 用户也可以收到错误提示信息.</p>

<p>首先, 我先处理<code>renderTemplate</code>中的错误:</p>

<pre><code>func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    t, err := template.ParseFiles(tmpl + &quot;.html&quot;)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    err = t.Execute(w, p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
</code></pre>

<p><code>http.Error</code>函数返回一个具体的错误码(这里是属于&rdquo;服务器错误&rdquo;类型)和错误信息.
看来刚才决定将模板处理独立到一个函数是一个正确的决定.</p>

<p>下面是修复后的<code>saveHandler</code>:</p>

<pre><code>func saveHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    err = p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>

<p><code>p.save()</code>时发生的错误信息也将报告给用户.</p>

<h2 id="缓存模板">缓存模板</h2>

<p>前面的实现有一个性能缺陷: <code>renderTemplate</code>每次都会调用<code>ParseFiles</code>函数.
更好的优化思路是只在初始化的使用调用一次<code>ParseFiles</code>, 将全部要处理的模板
放到一个<code>*Template</code>中. 然后可以使用<code>ExecuteTemplate</code>渲染指定的模板.</p>

<p>首先创建一个名位<code>templates</code>全局变量, 然后用<code>ParseFiles</code>进行初始化.</p>

<pre><code>var templates = template.Must(template.ParseFiles(&quot;edit.html&quot;, &quot;view.html&quot;))
</code></pre>

<p><code>template.Must</code>只是一个简便的包装, 当传递非<code>nil</code>的错误是抛出<code>panic</code>异常.
在这里抛出异常是合适的: 如果模板不能正常加载, 简单的处理方式就是退出程序.</p>

<p><code>ParseFiles</code>接收任意数量的字符串参数为名字的模板文件, 并将这些文件解析到以基本文件名
的模板. 如果我们需要更多的模板, 可以直接将模板文件名添加到<code>ParseFiles</code>参数中.</p>

<p>然后是修改<code>renderTemplate</code>函数, 调用<code>templates.ExecuteTemplate</code>渲染指定的模板:</p>

<pre><code>func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    err := templates.ExecuteTemplate(w, tmpl+&quot;.html&quot;, p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
</code></pre>

<p>需要注意的是模板名字对于模板文件的名字, 因此这里添加了&rdquo;.html&rdquo;后缀名.</p>

<h2 id="验证">验证</h2>

<p>你可能以及发现, 这个程序有严重的安全缺陷: 用户可以在服务器上读写任意独立路径.
为了降低这种风险, 我们编写一个函数以正则表达式的方式在验证标题的合法性.</p>

<p>首先, 要导入<code>&quot;regexp&quot;</code>包. 然后创建一个全局变量保存用于验证的正则表达式:</p>

<pre><code>var titleValidator = regexp.MustCompile(&quot;^[a-zA-Z0-9]+$&quot;)
</code></pre>

<p>函数<code>regexp.MustCompile</code>将分析和编译正则表达式, 返回<code>regexp.Regexp</code>.
<code>MustCompile</code>和<code>Compile</code>有些不同, <code>MustCompile</code>遇到错误时会抛出<code>panic</code>异常,
而<code>Compile</code>在遇到错误时通过第二个返回值返回错误.</p>

<p>现在, 让我们写一个函数<code>getTitle</code>, 从请求的URL提取标题, 并且测试是否是有效的表达式:</p>

<pre><code>func getTitle(w http.ResponseWriter, r *http.Request) (title string, err error) {
    title = r.URL.Path[lenPath:]
    if !titleValidator.MatchString(title) {
        http.NotFound(w, r)
        err = errors.New(&quot;Invalid Page Title&quot;)
    }
    return
}
</code></pre>

<p>如果标题是有效的, 将返回<code>nil</code>错误值. 如果标题无效, 函数会输出&rdquo;404 Not Found&rdquo;错误.</p>

<p>让我们将<code>getTitle</code>应用到每个处理程序：</p>

<pre><code>func viewHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)
        return
    }
    renderTemplate(w, &quot;view&quot;, p)
}

func editHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    renderTemplate(w, &quot;edit&quot;, p)
}

func saveHandler(w http.ResponseWriter, r *http.Request) {
    title, err := getTitle(w, r)
    if err != nil {
        return
    }
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    err = p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>

<h2 id="函数字面值和闭包">函数字面值和闭包</h2>

<p>每个处理函数为了增加错误错误引入了很多重复的代码. 如果是否可以将每个处理函数的
错误处理包装到一个函数? Go语言的闭包函数提供的强有力的手段, 刚好可以用在这里.</p>

<p>第一步, 我们重写每个处理函数, 增加一个标题字符串参数:</p>

<pre><code>func viewHandler(w http.ResponseWriter, r *http.Request, title string)
func editHandler(w http.ResponseWriter, r *http.Request, title string)
func saveHandler(w http.ResponseWriter, r *http.Request, title string)
</code></pre>

<p>然后, 我们顶一个包装函数, 参数类型和前面定义的处理函数类型一致, 最后返回
<code>http.HandlerFunc</code>(用于适配<code>http.HandleFunc</code>的参数类型):</p>

<pre><code>func makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Here we will extract the page title from the Request,
        // and call the provided handler 'fn'
    }
}
</code></pre>

<p>这里返回的函数就是一个闭包, 因为它引用了在它外部定义的局部变量的值.
在这里情况下, 变量<code>fn</code>(<code>makeHandler</code>函数的唯一参数)被闭包函数持有.
<code>fn</code>变量将对应我们的保存, 编辑 和 查看 的处理函数.</p>

<p>现在我们可以将<code>getTitle</code>的代码移到这里(还有一些细节的改动):</p>

<pre><code>func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        title := r.URL.Path[lenPath:]
        if !titleValidator.MatchString(title) {
            http.NotFound(w, r)
            return
        }
        fn(w, r, title)
    }
}
</code></pre>

<p><code>makeHandler</code>返回的是一个持有<code>http.ResponseWriter</code>和<code>http.Request</code>参数的闭包函数
(其实就是<code>http.HandlerFunc</code>类型). 闭包函数提取页面的标题, 并通过<code>TitleValidator</code>验证
标题是否符合正则表达式. 如果是无效的标题, 那么将使用<code>http.NotFound</code>输出错误的响应.
如果是有效的标题, 那么<code>fn</code>处理函数将会被调用.</p>

<p>现在我们可以在<code>main</code>函数注册的时候使用<code>makeHandler</code>包装具体的处理函数:</p>

<pre><code>func main() {
    http.HandleFunc(&quot;/view/&quot;, makeHandler(viewHandler))
    http.HandleFunc(&quot;/edit/&quot;, makeHandler(editHandler))
    http.HandleFunc(&quot;/save/&quot;, makeHandler(saveHandler))
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<p>Finally we remove the calls to getTitle from the handler functions, making them much simpler:</p>

<p>最后我们删除处理函数对<code>getTitle</code>的调用, 处理代码变得更加简单:</p>

<pre><code>func viewHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)
        return
    }
    renderTemplate(w, &quot;view&quot;, p)
}

func editHandler(w http.ResponseWriter, r *http.Request, title string) {
    p, err := loadPage(title)
    if err != nil {
        p = &amp;Page{Title: title}
    }
    renderTemplate(w, &quot;edit&quot;, p)
}

func saveHandler(w http.ResponseWriter, r *http.Request, title string) {
    body := r.FormValue(&quot;body&quot;)
    p := &amp;Page{Title: title, Body: []byte(body)}
    err := p.save()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)
}
</code></pre>

<h2 id="看看页面效果">看看页面效果!</h2>

<p><a href="http://golang.org/doc/articles/wiki/final.go">点击这里查看最终版本的代码</a>.</p>

<p>重新编译代码, 并且运行:</p>

<pre><code>$ go build wiki.go
$ ./wiki
</code></pre>

<p>浏览 <code>http://localhost:8080/view/ANewPage</code> 将会看到编辑页面.
你可以输入一些文字, 点击 &lsquo;save&rsquo; 保存, 然后重新定向到新创建的页面.</p>

<h2 id="其他任务">其他任务</h2>

<p>还可以根据自己的兴趣选择一些简单的扩展任务:</p>

<ul>
<li>保存模板到<code>tmpl/</code>目录, 保存数据到<code>data/</code>目录.</li>
<li>增加一个根目录的处理函数, 重定向到<code>/view/FrontPage</code>.</li>
<li>Spruce up the page templates by making them valid HTML and adding some CSS rules.</li>
<li>完善页面模板, 让它们输出有效的HTML, 并且添加一些CSS规则。</li>
<li>通过将<code>[PageName]</code>转换位<code>&lt;a href=&quot;/view/PageName&quot;&gt;PageName&lt;/a&gt;</code>实现页面之间的链接.
(提示: 可以使用<code>regexp.ReplaceAllFunc</code>实现该功能)</li>
</ul>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">chai2010</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2013-04-06</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/golang/">golang</a>
          
          <a href="/tags/web/">web</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/golang/go-preview-2013/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">为什么除了Go语言, 其他类C语言都是垃圾[转]</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/misc/qt5-i18n/">
            <span class="next-text nav-default">VC2010下Qt5的中文乱码问题</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>

    <script src="https://giscus.app/client.js"
    data-repo="chai2010/chai2010.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjQxNjY5MDk="
    data-category="General"
    data-category-id="DIC_kwDOB2ai_c4CR3mk"
    data-mapping="og:title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  

  <span class="copyright-year">
    &copy;
    
      2006 -
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">chai2010</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>


</body>
</html>
