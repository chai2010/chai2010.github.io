<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go语言的RPC介绍(含Protobuf-RPC) - chai2010 的博客</title>
  <link rel="alternate" hreflang="zh-CN" href="https://chai2010.cn/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="chai2010" />
  <meta name="description" content="本文在 Golang中国博客 的地址: http://blog.go-china.org/09-protorpc 标准库的RPC RPC是远程调用的简称, 简单的说就是要像调用本地函数一样调用服务器的函数. Go语言的标准库" />

  <meta name="keywords" content="chai2010, Go, Golang" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="https://chai2010.cn/post/golang/go-protorpc-2014/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">


<meta property="og:title" content="Go语言的RPC介绍(含Protobuf-RPC)" />
<meta property="og:description" content="本文在 Golang中国博客 的地址: http://blog.go-china.org/09-protorpc 标准库的RPC RPC是远程调用的简称, 简单的说就是要像调用本地函数一样调用服务器的函数. Go语言的标准库" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chai2010.cn/post/golang/go-protorpc-2014/" />



<meta property="article:published_time" content="2014-01-08T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2014-01-08T00:00:00&#43;00:00"/>











<meta itemprop="name" content="Go语言的RPC介绍(含Protobuf-RPC)">
<meta itemprop="description" content="本文在 Golang中国博客 的地址: http://blog.go-china.org/09-protorpc 标准库的RPC RPC是远程调用的简称, 简单的说就是要像调用本地函数一样调用服务器的函数. Go语言的标准库">


<meta itemprop="datePublished" content="2014-01-08T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2014-01-08T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2852">



<meta itemprop="keywords" content="golang,protorpc,protobuf," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Go语言的RPC介绍(含Protobuf-RPC)"/>
<meta name="twitter:description" content="本文在 Golang中国博客 的地址: http://blog.go-china.org/09-protorpc 标准库的RPC RPC是远程调用的简称, 简单的说就是要像调用本地函数一样调用服务器的函数. Go语言的标准库"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-621845-14', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">chai2010 的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/talks/">
        <li class="mobile-menu-item">报告</li>
      </a><a href="/books/">
        <li class="mobile-menu-item">图书</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">chai2010 的博客</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/talks/">报告</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/books/">图书</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Go语言的RPC介绍(含Protobuf-RPC)</h1>

      <div class="post-meta">
        <span class="post-time"> 2014-01-08 </span>
        <div class="post-category">
            
              <a href="/categories/golang/"> golang </a>
            
          </div>
        <span class="more-meta"> 约 2852 字 </span>
        <span class="more-meta"> 预计阅读 6 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#标准库的rpc">标准库的RPC</a></li>
<li><a href="#基于-json-的-rpc-调用">基于 JSON 的 RPC 调用</a></li>
<li><a href="#基于-protobuf-的-rpc-调用">基于 Protobuf 的 RPC 调用</a></li>
<li><a href="#c-调用-go-提供的-protobuf-rpc-服务">C++ 调用 Go 提供的 Protobuf-RPC 服务</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<p>本文在 <a href="http://blog.go-china.org/">Golang中国博客</a> 的地址: <a href="http://blog.go-china.org/09-protorpc">http://blog.go-china.org/09-protorpc</a></p>

<h2 id="标准库的rpc">标准库的RPC</h2>

<p>RPC是远程调用的简称, 简单的说就是要像调用本地函数一样调用服务器的函数.</p>

<p>Go语言的标准库已经提供了RPC框架和不同的RPC实现.</p>

<p>下面是一个服务器的例子:</p>

<pre><code>type Echo int

func (t *Echo) Hi(args string, reply *string) error {
    *reply = &quot;echo:&quot; + args
    return nil
}

func main() {
    rpc.Register(new(Echo))
    rpc.HandleHTTP()
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    http.Serve(l, nil)
}
</code></pre>

<p>其中 <code>rpc.Register</code> 用于注册RPC服务, 默认的名字是对象的类型名字(这里是<code>Echo</code>). 如果需要指定特殊的名字, 可以用 <code>rpc.RegisterName</code> 进行注册.</p>

<p>被注册对象的类型所有满足以下规则的方法会被导出到RPC服务接口:</p>

<pre><code>func (t *T) MethodName(argType T1, replyType *T2) error
</code></pre>

<p>被注册对应至少要有一个方法满足这个特征, 否则可能会注册失败.</p>

<p>然后 <code>rpc.HandleHTTP</code> 用于指定 RPC 的传输协议, 这里是采用 http 协议作为RPC调用的载体. 用户也可以用<code>rpc.ServeConn</code>接口, 定制自己的传输协议.</p>

<p>客户端可以这样调用<code>Echo.Hi</code>接口:</p>

<pre><code>func main() {
    client, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        log.Fatal(&quot;dialing:&quot;, err)
    }

    var args = &quot;hello rpc&quot;
    var reply string
    err = client.Call(&quot;Echo.Hi&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    fmt.Printf(&quot;Arith: %d*%d=%d\n&quot;, args.A, args.B, reply)
}
</code></pre>

<p>客户端先用<code>rpc.DialHTTP</code>和RPC服务器进行一个链接(协议必须匹配).</p>

<p>然后通过返回的<code>client</code>对象进行远程函数调用. 函数的名字是由<code>client.Call</code> 第一个参数指定(是一个字符串).</p>

<p>基于HTTP的RPC调用一般是在调试时使用, 默认可以通过浏览<code>&quot;127.0.0.1:1234/debug/rpc&quot;</code>页面查看RPC的统计信息.</p>

<h2 id="基于-json-的-rpc-调用">基于 JSON 的 RPC 调用</h2>

<p>在上面的RPC例子中, 我们采用了默认的HTTP协议作为RPC调用的传输载体.</p>

<p>因为内置<code>net/rpc</code>包接口设计的缺陷, 我们无法使用<code>jsonrpc</code>等定制的编码作为<code>rpc.DialHTTP</code>的底层协议. 如果需要让<code>jsonrpc</code>支持<code>rpc.DialHTTP</code>函数, 需要调整rpc的接口.</p>

<p>以前有个<a href="https://code.google.com/p/go/issues/detail?id=2738">Issue2738</a>是针对这个问题. 我曾提交的 <a href="https://codereview.appspot.com/10704046/">CL10704046</a> 补丁用于修复这个问题. 不过因为涉及到增加rpc的接口, 官方没有接受(因为自己重写一个<code>DialHTTP</code>会更简单).</p>

<p>除了传输协议, 还有可以指定一个RPC编码协议, 用于编码/节目RPC调用的函数参数和返回值. RPC调用不指定编码协议时, 默认采用Go语言特有的<code>gob</code>编码协议.</p>

<p>因为, 其他语言一般都不支持Go语言的<code>gob</code>协议, 因此如果需要跨语言RPC调用就需要
采用通用的编码协议.</p>

<p>Go的标准库还提供了一个<code>&quot;net/rpc/jsonrpc&quot;</code>包, 用于提供基于JSON编码的RPC支持.</p>

<p>服务器部分只需要用<code>rpc.ServeCodec</code>指定json编码协议就可以了:</p>

<pre><code>func main() {
    lis, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        return err
    }
    defer lis.Close()

    srv := rpc.NewServer()
    if err := srv.RegisterName(&quot;Echo&quot;, new(Echo)); err != nil {
        return err
    }

    for {
        conn, err := lis.Accept()
        if err != nil {
            log.Fatalf(&quot;lis.Accept(): %v\n&quot;, err)
        }
        go srv.ServeCodec(jsonrpc.NewServerCodec(conn))
    }
}
</code></pre>

<p>客户端部分值需要用 <code>jsonrpc.Dial</code> 代替 <code>rpc.Dial</code> 就可以了:</p>

<pre><code>func main() {
    client, err := jsonrpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        log.Fatal(&quot;dialing:&quot;, err)
    }
    ...
}
</code></pre>

<p>如果需要在其他语言中使用<code>jsonrpc</code>和Go语言进行通讯, 需要封装一个和<code>jsonrpc</code>
匹配的库.</p>

<p>关于<code>jsonrpc</code>的实现细节这里就不展开讲了, 感兴趣的话可以参考这篇文章: <a href="http://blog.golang.org/json-rpc-tale-of-interfaces">JSON-RPC: a tale of interfaces</a>.</p>

<h2 id="基于-protobuf-的-rpc-调用">基于 Protobuf 的 RPC 调用</h2>

<p><a href="http://code.google.com/p/protobuf/;">Protobuf</a> 是 Google 公司开发的编码协议. 它的优势是编码后的数据体积比较小(并不是压缩算法), 比较适合用于命令的传输编码.</p>

<p>Protobuf 官方团队提供 Java/C++/Python 几个语言的支持, Go语言的版本由Go团队提供支持, 其他语言由第三方支持.</p>

<p>Protobuf 的语言规范中可以定义RPC接口. 但是在Go语言和C++版本的Protobuf中都没有生成RPC的实现.</p>

<p>不过作者在 Go语言版本的Protobuf基础上开发了 RPC 的实现 <a href="https://code.google.com/p/protorpc/">protorpc</a>, 同时提供的 <code>protoc-gen-go</code>命令可以生成相应的RPC代码. 项目地址: <a href="https://code.google.com/p/protorpc/">https://code.google.com/p/protorpc/</a></p>

<p>该实现支持Go语言和C++语言, 在Protobuf官方wiki的第三方RPC实现列表中有介绍: <a href="https://code.google.com/p/protobuf/wiki/ThirdPartyAddOns#RPC_Implementations">https://code.google.com/p/protobuf/wiki/ThirdPartyAddOns#RPC_Implementations</a></p>

<p>要使用 <a href="https://code.google.com/p/protorpc/">protorpc</a>, 需要先在proto文件定义接口(<code>arith.pb/arith.proto</code>):</p>

<pre><code>package arith;

// go use cc_generic_services option
option cc_generic_services = true;

message ArithRequest {
    optional int32 a = 1;
    optional int32 b = 2;
}

message ArithResponse {
    optional int32 val = 1;
    optional int32 quo = 2;
    optional int32 rem = 3;
}

service ArithService {
    rpc multiply (ArithRequest) returns (ArithResponse);
    rpc divide (ArithRequest) returns (ArithResponse);
}
</code></pre>

<p><a href="https://code.google.com/p/protorpc/">protorpc</a>使用<code>cc_generic_services</code>选择控制是否输出RPC代码. 因此, 需要设置<code>cc_generic_services</code>为<code>true</code>.</p>

<p>然后下载 <a href="https://code.google.com/p/protobuf/downloads/list">protoc-2.5.0-win32.zip</a>, 解压后可以得到一个 <code>protoc.exe</code> 的编译命令.</p>

<p>然后使用下面的命令获取 <a href="https://code.google.com/p/protorpc/">protorpc</a> 和对应的 <code>protoc-gen-go</code> 插件.</p>

<pre><code>go get code.google.com/p/protorpc
go get code.google.com/p/protorpc/protoc-gen-go
</code></pre>

<p>需要确保 <code>protoc.exe</code> 和 <code>protoc-gen-go.exe</code> 都在 <code>$PATH</code> 中. 然后运行以下命令将前面的接口文件转换为Go代码:</p>

<pre><code>cd arith.pb &amp;&amp; protoc --go_out=. arith.proto
</code></pre>

<p>新生成的文件为<code>arith.pb/arith.pb.go</code>.</p>

<p>下面是基于 Protobuf-RPC 的服务器:</p>

<pre><code>package main

import (
    &quot;errors&quot;

    &quot;code.google.com/p/goprotobuf/proto&quot;

    &quot;./arith.pb&quot;
)

type Arith int

func (t *Arith) Multiply(args *arith.ArithRequest, reply *arith.ArithResponse) error {
    reply.Val = proto.Int32(args.GetA() * args.GetB())
    return nil
}

func (t *Arith) Divide(args *arith.ArithRequest, reply *arith.ArithResponse) error {
    if args.GetB() == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    reply.Quo = proto.Int32(args.GetA() / args.GetB())
    reply.Rem = proto.Int32(args.GetA() % args.GetB())
    return nil
}

func main() {
    arith.ListenAndServeArithService(&quot;tcp&quot;, &quot;:1984&quot;, new(Arith))
}
</code></pre>

<p>其中导入的 <code>&quot;./arith.pb&quot;</code> 的名字为 <code>arith</code>, 在 <code>arith.pb/arith.proto</code> 文件中定义(这2个可能不同名, 导入时要小心).</p>

<p><code>arith.ArithRequest</code>和<code>arith.ArithResponse</code>是RPC接口的输入和输出参数, 也是在在 <code>arith.pb/arith.proto</code> 文件中定义的.</p>

<p>同时生成的还有一个<code>arith.ListenAndServeArithService</code>函数, 用于启动RPC服务. 该函数的第三个参数是RPC的服务对象, 必须要满足 <code>arith.EchoService</code> 接口的定义.</p>

<p>客户端的使用也很简单, 只要一个 <code>arith.DialArithService</code> 就可以链接了:</p>

<pre><code>stub, client, err := arith.DialArithService(&quot;tcp&quot;, &quot;127.0.0.1:1984&quot;)
if err != nil {
    log.Fatal(`arith.DialArithService(&quot;tcp&quot;, &quot;127.0.0.1:1984&quot;):`, err)
}
defer client.Close()
</code></pre>

<p><code>arith.DialArithService</code> 返回了一个 <code>stub</code> 对象, 该对象已经绑定了RPC的各种方法, 可以直接调用(不需要用字符串指定方法名字):</p>

<pre><code>var args ArithRequest
var reply ArithResponse

args.A = proto.Int32(7)
args.B = proto.Int32(8)
if err = stub.Multiply(&amp;args, &amp;reply); err != nil {
    log.Fatal(&quot;arith error:&quot;, err)
}
fmt.Printf(&quot;Arith: %d*%d=%d&quot;, args.GetA(), args.GetB(), reply.GetVal())
</code></pre>

<p>相比标准的RPC的库, <a href="https://code.google.com/p/protorpc/">protorpc</a> 由以下几个优点:</p>

<ol>
<li>采用标准的Protobuf协议, 便于和其他语言交互</li>
<li>自带的 <code>protoc-gen-go</code> 插件可以生成RPC的代码, 简化使用</li>
<li>服务器注册和调用客户端都是具体类型而不是字符串和<code>interface{}</code>, 这样可以由编译器保证安全</li>
<li>底层采用了<code>snappy</code>压缩传输的数据, 提高效率</li>
</ol>

<p>不足之处是使用流程比标准RPC要繁复(需要将proto转换为Go代码).</p>

<h2 id="c-调用-go-提供的-protobuf-rpc-服务">C++ 调用 Go 提供的 Protobuf-RPC 服务</h2>

<p><a href="https://code.google.com/p/protorpc/">protorpc</a> 同时也提供了 C++ 语言的实现.</p>

<p>C++版本的安装如下:</p>

<ol>
<li><code>hg clone https://code.google.com/p/protorpc.cxx/</code></li>
<li><code>cd protorpc.cxx</code></li>
<li>build with cmake</li>
</ol>

<p>C++ 版本 的 <a href="https://code.google.com/p/protorpc/">protorpc</a> 对 <code>protoc.exe</code> 扩展了一个
<code>--cxx_out</code> 选项, 用于生成RPC的代码:</p>

<pre><code>${protorpc_root}/protobuf/bin/protoc --cxx_out=. arith.proto
</code></pre>

<p><em>注:<code>--cxx_out</code> 选项生成的代码除了RPC支持外, 还有xml的序列化和反序列化支持.</em></p>

<p>下面是 C++ 的客户端链接 Go 语言版本的 服务器:</p>

<pre><code>#include &quot;arith.pb.h&quot;

#include &lt;google/protobuf/rpc/rpc_server.h&gt;
#include &lt;google/protobuf/rpc/rpc_client.h&gt;

int main() {
  ::google::protobuf::rpc::Client client(&quot;127.0.0.1&quot;, 1234);

  service::ArithService::Stub arithStub(&amp;client);

  ::service::ArithRequest arithArgs;
  ::service::ArithResponse arithReply;
  ::google::protobuf::rpc::Error err;

  // EchoService.mul
  arithArgs.set_a(3);
  arithArgs.set_b(4);
  err = arithStub.multiply(&amp;arithArgs, &amp;arithReply);
  if(!err.IsNil()) {
    fprintf(stderr, &quot;arithStub.multiply: %s\n&quot;, err.String().c_str());
    return -1;
  }
  if(arithReply.c() != 12) {
    fprintf(stderr, &quot;arithStub.multiply: expected = %d, got = %d\n&quot;, 12, arithReply.c());
    return -1;
  }

  printf(&quot;Done.\n&quot;);
  return 0;
}
</code></pre>

<p>详细的使用说明请参考: <a href="https://code.google.com/p/protorpc/source/browse/README.md?repo=cxx">README.md</a> .
更多的例子请参考: <a href="http://code.google.com/p/protorpc/source/browse/tests/rpctest/rpcserver.cc?repo=cxx">rpcserver.cc</a>
和 <a href="http://code.google.com/p/protorpc/source/browse/tests/rpctest/rpcclient.cc?repo=cxx">rpcclient.cc</a></p>

<h2 id="总结">总结</h2>

<p>Go语言的RPC客户端是一个使用简单, 而且功能强大的RPC库. 基于标准的RPC库我们可以方便的定制自己的RPC实现(传输协议和串行化协议都可以定制).</p>

<p>不过在开发 <a href="https://code.google.com/p/protorpc/">protorpc</a> 的过程中也发现了<code>net/rpc</code>包的一些不足之处:</p>

<ul>
<li>内置的<code>HTTP</code>协议的RPC的串行化协议和传输协议耦合过于紧密, 用户扩展的协议无法支持内置的<code>HTTP</code>传输协议(因为<code>rpc.Server</code>和<code>rpc.Client</code>接口缺陷导致的问题)</li>
<li><code>rpc.Server</code> 只能注册 <code>rpc.ServerCodec</code>, 而不能注册工厂函数. 而<code>jsonrpc.NewServerCodec</code>需要依赖先建立链接(<code>conn</code>参数), 这样导致了<code>HTTP</code>协议只能支持内置的<code>gob</code>协议</li>
<li><code>rpc.Client</code> 的问题和 <code>rpc.Server</code> 类似</li>
</ul>

<p>因为Go1需要保证API的兼容性, 因此上述的问题只能希望在未来的Go2能得到改善.</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">chai2010</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2014-01-08</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/golang/">golang</a>
          
          <a href="/tags/protorpc/">protorpc</a>
          
          <a href="/tags/protobuf/">protobuf</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/golang/go-gettext-2014/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go语言的国际化支持(资源文件翻译)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/golang/go-gettext/">
            <span class="next-text nav-default">Go语言的国际化支持(基于gettext-go)</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>

    <script src="https://giscus.app/client.js"
    data-repo="chai2010/chai2010.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjQxNjY5MDk="
    data-category="General"
    data-category-id="DIC_kwDOB2ai_c4CR3mk"
    data-mapping="og:title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  

  <span class="copyright-year">
    &copy;
    
      2006 -
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">chai2010</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>


</body>
</html>
