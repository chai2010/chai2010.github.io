<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>切片：用法和本质[翻译] - chai2010 的博客</title>
  <link rel="alternate" hreflang="zh-CN" href="https://chai2010.cn/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="chai2010" />
  <meta name="description" content="原文： http://golang.org/doc/articles/slices_usage_and_internals.html Go的切片类型为处理同类型数据序列提供一个方便而高效的方式。切片有些类似于其他语言中的数组，但是有一些不同寻常的特性。本文将深入切片" />

  <meta name="keywords" content="chai2010, Go, Golang" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="https://chai2010.cn/post/golang/slice2013/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">


<meta property="og:title" content="切片：用法和本质[翻译]" />
<meta property="og:description" content="原文： http://golang.org/doc/articles/slices_usage_and_internals.html Go的切片类型为处理同类型数据序列提供一个方便而高效的方式。切片有些类似于其他语言中的数组，但是有一些不同寻常的特性。本文将深入切片" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chai2010.cn/post/golang/slice2013/" />



<meta property="article:published_time" content="2013-04-04T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2013-04-04T00:00:00&#43;00:00"/>











<meta itemprop="name" content="切片：用法和本质[翻译]">
<meta itemprop="description" content="原文： http://golang.org/doc/articles/slices_usage_and_internals.html Go的切片类型为处理同类型数据序列提供一个方便而高效的方式。切片有些类似于其他语言中的数组，但是有一些不同寻常的特性。本文将深入切片">


<meta itemprop="datePublished" content="2013-04-04T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2013-04-04T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2611">



<meta itemprop="keywords" content="golang," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="切片：用法和本质[翻译]"/>
<meta name="twitter:description" content="原文： http://golang.org/doc/articles/slices_usage_and_internals.html Go的切片类型为处理同类型数据序列提供一个方便而高效的方式。切片有些类似于其他语言中的数组，但是有一些不同寻常的特性。本文将深入切片"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-621845-14', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">chai2010 的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/talks/">
        <li class="mobile-menu-item">报告</li>
      </a><a href="/books/">
        <li class="mobile-menu-item">图书</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">chai2010 的博客</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/talks/">报告</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/books/">图书</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">切片：用法和本质[翻译]</h1>

      <div class="post-meta">
        <span class="post-time"> 2013-04-04 </span>
        <div class="post-category">
            
              <a href="/categories/golang/"> golang </a>
            
          </div>
        <span class="more-meta"> 约 2611 字 </span>
        <span class="more-meta"> 预计阅读 6 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#数组">数组</a></li>
<li><a href="#切片">切片</a></li>
<li><a href="#切片的本质">切片的本质</a></li>
<li><a href="#切片生长-复制和追加">切片生长（复制和追加）</a></li>
<li><a href="#可能的-陷阱">可能的“陷阱”</a></li>
<li><a href="#进阶阅读">进阶阅读</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<ul>
<li>原文： <a href="http://golang.org/doc/articles/slices_usage_and_internals.html">http://golang.org/doc/articles/slices_usage_and_internals.html</a></li>
</ul>

<p>Go的切片类型为处理同类型数据序列提供一个方便而高效的方式。切片有些类似于其他语言中的数组，但是有一些不同寻常的特性。本文将深入切片的本质，并讲解它的用法。</p>

<h2 id="数组">数组</h2>

<p>Go的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要要理解数组。</p>

<p>数组类型由指定和长度和元素类型定义。例如，<code>[4]int</code> 类型表示一个四个整数的序列。数组的长度是固定的，长度是数组类型的一部分（<code>int[4]</code> 和 <code>[5]int</code> 是完全不同的类型）。数组可以以常规的索引方式访问，表达式 <code>s[n]</code> 访问数组的第 <code>n</code> 个元素。</p>

<pre><code>var a [4]int
a[0] = 1
i := a[0]
// i == 1
</code></pre>

<p>数组不需要显式的初始化；数组元素会自动初始化为零值：</p>

<pre><code>// a[2] == 0, the zero value of the int type
</code></pre>

<p>类型[4]int对应内存中四个连续的整数：</p>

<p><img src="/images/slice2013-01.png" alt="" /></p>

<p>Go的数组是值语义。一个数组变量表示整个数组，它不是指向第一个元素的指针（比如C语言的数组）。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。（为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。）可以将数组看作一个特殊的struct，结构的字段名对应数组的索引，同时成员的数目固定。</p>

<p>数组的字面值想这样：</p>

<pre><code>b := [2]string{&quot;Penn&quot;, &quot;Teller&quot;}
</code></pre>

<p>当然，也可以让编译器统计数组字面值中元素的数目：</p>

<pre><code>b := [...]string{&quot;Penn&quot;, &quot;Teller&quot;}
</code></pre>

<p>这两种写法，<code>b</code> 都是对应 <code>[2]string</code> 类型。</p>

<h2 id="切片">切片</h2>

<p>数组虽然有适用它们的地方，但是数组不够灵活，因此在Go代码中数组使用的并不多。但是，切片则使用得相当广泛。切片基于数组构建，但是提供更强的功能和便利。</p>

<p>切片的类型是 <code>[]T</code>，<code>T</code> 是切片元素的类型。和数组不同的是，切片没有固定的长度。</p>

<p>切片的字面值和数组字面值很像，不过切片没有指定元素个数：</p>

<pre><code>letters := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
</code></pre>

<p>切片可以内置函数 <code>make</code> 创建，函数签名为：</p>

<pre><code>func make([]T, len, cap) []T
</code></pre>

<p><code>T</code> 代表被创建的切片元素的类型。函数 <code>make</code> 接受一个类型、一个长度和一个可选的容量参数。调用 <code>make</code> 时，内部会分配一个数组，然后返回数组对应的切片。</p>

<pre><code>var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
</code></pre>

<p>当容量参数被忽略时，它默认为指定的长度。下面是简洁的写法：</p>

<pre><code>s := make([]byte, 5)
</code></pre>

<p>可以使用内置函数 <code>len</code> 和 <code>cap</code> 获取切片的长度和容量信息。</p>

<pre><code>len(s) == 5
cap(s) == 5
</code></pre>

<p>接下来的两个小节将讨论长度和容量之间的关系。</p>

<p>零值的切片类型变量为 <code>nil</code>。对于零值切片变量，<code>len</code> 和 <code>cap</code> 都将返回 <code>0</code>。</p>

<p>切片也可以基于现有的切片或数组生成。切分的范围由两个由冒号分割的索引对应的半开区间指定。例如，表达式 <code>b[1:4]</code> 创建的切片引用数组 <code>b</code> 的第 <code>1</code> 到 <code>3</code> 个元素空间（对应切片的索引为0到2）。</p>

<pre><code>b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
</code></pre>

<p>切片的开始和结束的索引都是可选的；它们分别默认为零和数组的长度。</p>

<pre><code>// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
</code></pre>

<p>下面语法也是基于数组创建一个切片：</p>

<pre><code>x := [3]string{&quot;Лайка&quot;, &quot;Белка&quot;, &quot;Стрелка&quot;}
s := x[:] // a slice referencing the storage of x
</code></pre>

<h2 id="切片的本质">切片的本质</h2>

<p>一个切片是一个数组切割区间的描述。它包含了指向数组的指针，切割区间的长度，和容量（切割区间的最大长度）。</p>

<p><img src="/images/slice2013-02.png" alt="" /></p>

<p>前面使用 <code>make([]byte, 5)</code> 创建的切片变量s的结构如下：</p>

<p><img src="/images/slice2013-03.png" alt="" /></p>

<p>长度是切片引用的元素数目。容量是底层数组的元素数目（从切片指针开始）。关于长度和容量和区域将在下一个例子说明。</p>

<p>我们继续对 <code>s</code> 进行切分，观察切片的数据结构和它引用的底层数组：</p>

<pre><code>s = s[2:4]
</code></pre>

<p><img src="/images/slice2013-04.png" alt="" /></p>

<p>切片并不复制整个切片元素。它创建一个新的切片执行同样的底层数组。这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素同样会影响到原始的切片。</p>

<pre><code>d := []byte{'r', 'o', 'a', 'd'}
e := d[2:]
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
</code></pre>

<p>前面创建的切片 <code>s</code> 长度小于它的容量。我们可以增长切片的长度为它的容量：</p>

<pre><code>s = s[:cap(s)]
</code></pre>

<p><img src="/images/slice2013-05.png" alt="" /></p>

<p>切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。</p>

<h2 id="切片生长-复制和追加">切片生长（复制和追加）</h2>

<p>要增加切片的容量必须创建一个新的、更大容量的切片，然后将原有切片的内容复制到新的切片。整个技术是一些支持动态数组语言的常见实现。下面的例子将切片 <code>s</code> 容量翻倍，先创建一个2倍容量的新切片 <code>t</code>，复制 <code>s</code> 的元素到 <code>t</code>，然后将 <code>t</code> 赋值给 <code>s</code>：</p>

<pre><code>t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0
for i := range s {
        t[i] = s[i]
}
s = t
</code></pre>

<p>循环中复制的操作可以由 <code>copy</code> 内置函数替代。<code>copy</code> 函数将源切片的元素复制到目的切片。它返回复制元素的数目。</p>

<pre><code>func copy(dst, src []T) int
</code></pre>

<p><code>copy</code> 函数支持不同长度的切片之间的复制（它只复制最小切片长度的元素）。此外，<code>copy</code> 函数可以正确处理源和目的切片有重叠的情况。</p>

<p>使用 <code>copy</code> 函数，我们可以简化上面的代码片段：</p>

<pre><code>t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre>

<p>一个常见的操作是将数据追加到切片的尾部。下面的函数将元素追加到切片尾部，必要的话会增加切片的容量，最后返回更新的切片：</p>

<pre><code>func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n &gt; cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}
</code></pre>

<p>下面是 <code>AppendByte</code> 的一种用法：</p>

<pre><code>p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
</code></pre>

<p>类似 <code>AppendByte</code> 的函数比较实用，因为它提供了切片容量增长的完全控制。根据程序的特点，可能希望分配较小的活较大的块，或则是超过某个大小再分配。</p>

<p>但大多数程序不需要完全的控制，因此Go提供了一个内置函数 <code>append</code>，用于大多数场合；它的函数签名：</p>

<pre><code>func append(s []T, x ...T) []T
</code></pre>

<p>append函数将x追加到切片s的末尾，并且在必要的时候增加容量。</p>

<pre><code>a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre>

<p>如果是要将一个切片追加到另一个切片尾部，需要使用&hellip;语法将第2个参数展开为参数列表。</p>

<pre><code>a := []string{&quot;John&quot;, &quot;Paul&quot;}
b := []string{&quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
a = append(a, b...) // equivalent to &quot;append(a, b[0], b[1], b[2])&quot;
// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
</code></pre>

<p>可以声明一个零值切片（<code>nil</code>），然后在循环中向切片追加数据：</p>

<pre><code>// Filter returns a new slice holding only
// the elements of s that satisfy f()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, i := range s {
        if fn(i) {
            p = append(p, i)
        }
    }
    return p
}
</code></pre>

<h2 id="可能的-陷阱">可能的“陷阱”</h2>

<p>正如前面所说，切片操作并不会复制底层的数组。此层的数组将被保存在内存中，知道它不再被引用。有时候可能会因为一个小的内存引用导致保存所有的数据。</p>

<p>例如，<code>FindDigits</code> 函数加载整个文件到内存，然后搜索第一个连续的数字，最后结果以切片方式返回。</p>

<pre><code>var digitRegexp = regexp.MustCompile(&quot;[0-9]+&quot;)

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
</code></pre>

<p>这段代码的行为和广告类似，返回的 <code>[]byte</code> 指向保存整个文件的数组。因为切片引用了原始的数组，导致GC不能释放数组的空间；一个小的需求导致需要保存整个文件。</p>

<p>要修复整个问题，可以将感兴趣的数据复制到一个新的切片中：</p>

<pre><code>func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
</code></pre>

<p>可以使用 <code>append</code> 实现一个更简洁的版本。这留给读者作为练习。</p>

<h2 id="进阶阅读">进阶阅读</h2>

<p><a href="http://golang.org/doc/effective_go.html">Effective Go</a> 有关于切片和数组的深入探讨，并且Go <a href="http://golang.org/doc/go_spec.html">语言规范</a> 定义了切片的相关、辅助、专有的函数。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">chai2010</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2013-04-04</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/golang/">golang</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/misc/qt5-i18n/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">VC2010下Qt5的中文乱码问题</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/golang/cgo2013/">
            <span class="next-text nav-default">C？Go？Cgo！[翻译]</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>

    <script src="https://giscus.app/client.js"
    data-repo="chai2010/chai2010.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjQxNjY5MDk="
    data-category="General"
    data-category-id="DIC_kwDOB2ai_c4CR3mk"
    data-mapping="og:title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  

  <span class="copyright-year">
    &copy;
    
      2006 -
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">chai2010</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>


</body>
</html>
