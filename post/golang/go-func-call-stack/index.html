<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go语言的函数调用信息 - chai2010 的博客</title>
  <link rel="alternate" hreflang="zh-CN" href="https://chai2010.cn/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="chai2010" />
  <meta name="description" content="By chaishushan{AT}gmail.com 注: 本文初稿发在 Golang 中国博客, 这里的内容有部分修改. 函数的调用信息是程序中比较重要运行期信息, 在很多场合都会用到(比如调试或日志). Go语" />

  <meta name="keywords" content="chai2010, Go, Golang" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="https://chai2010.cn/post/golang/go-func-call-stack/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">


<meta property="og:title" content="Go语言的函数调用信息" />
<meta property="og:description" content="By chaishushan{AT}gmail.com 注: 本文初稿发在 Golang 中国博客, 这里的内容有部分修改. 函数的调用信息是程序中比较重要运行期信息, 在很多场合都会用到(比如调试或日志). Go语" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chai2010.cn/post/golang/go-func-call-stack/" />



<meta property="article:published_time" content="2014-01-04T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2014-01-04T00:00:00&#43;00:00"/>











<meta itemprop="name" content="Go语言的函数调用信息">
<meta itemprop="description" content="By chaishushan{AT}gmail.com 注: 本文初稿发在 Golang 中国博客, 这里的内容有部分修改. 函数的调用信息是程序中比较重要运行期信息, 在很多场合都会用到(比如调试或日志). Go语">


<meta itemprop="datePublished" content="2014-01-04T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2014-01-04T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4384">



<meta itemprop="keywords" content="golang," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Go语言的函数调用信息"/>
<meta name="twitter:description" content="By chaishushan{AT}gmail.com 注: 本文初稿发在 Golang 中国博客, 这里的内容有部分修改. 函数的调用信息是程序中比较重要运行期信息, 在很多场合都会用到(比如调试或日志). Go语"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-621845-14', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">chai2010 的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/talks/">
        <li class="mobile-menu-item">报告</li>
      </a><a href="/books/">
        <li class="mobile-menu-item">图书</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">chai2010 的博客</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/talks/">报告</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/books/">图书</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Go语言的函数调用信息</h1>

      <div class="post-meta">
        <span class="post-time"> 2014-01-04 </span>
        <div class="post-category">
            
              <a href="/categories/golang/"> golang </a>
            
          </div>
        <span class="more-meta"> 约 4384 字 </span>
        <span class="more-meta"> 预计阅读 9 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#runtime-caller-的用法"><code>runtime.Caller</code> 的用法</a></li>
<li><a href="#runtime-callers-的用法"><code>runtime.Callers</code> 的用法</a></li>
<li><a href="#runtime-callers-和-runtime-caller-的异同"><code>runtime.Callers</code> 和 <code>runtime.Caller</code> 的异同</a></li>
<li><a href="#runtime-funcforpc-的用途"><code>runtime.FuncForPC</code> 的用途</a></li>
<li><a href="#定制的-callername-函数">定制的 <code>CallerName</code> 函数</a></li>
<li><a href="#go语言中函数的类型">Go语言中函数的类型</a></li>
<li><a href="#改进的-callername-函数">改进的 <code>CallerName</code> 函数</a></li>
<li><a href="#callername-函数的不足之处"><code>CallerName</code> 函数的不足之处</a></li>
<li><a href="#不同go程序启动流程">不同Go程序启动流程</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<p><em>By chaishushan{AT}gmail.com</em></p>

<p><em>注: 本文初稿发在 <a href="http://blog.go-china.org/04-go-caller">Golang 中国博客</a>, 这里的内容有部分修改.</em></p>

<p>函数的调用信息是程序中比较重要运行期信息, 在很多场合都会用到(比如调试或日志).</p>

<p>Go语言 <code>runtime</code> 包的 <code>runtime.Caller</code> / <code>runtime.Callers</code> / <code>runtime.FuncForPC</code> 等几个函数提供了获取函数调用者信息的方法.</p>

<p>这几个函数的文档链接:</p>

<ul>
<li><a href="http://golang.org/pkg/runtime/#Caller">http://golang.org/pkg/runtime/#Caller</a></li>
<li><a href="http://golang.org/pkg/runtime/#Callers">http://golang.org/pkg/runtime/#Callers</a></li>
<li><a href="http://golang.org/pkg/runtime/#FuncForPC">http://golang.org/pkg/runtime/#FuncForPC</a></li>
</ul>

<p>本文主要讲述这几个函数的用法.</p>

<h2 id="runtime-caller-的用法"><code>runtime.Caller</code> 的用法</h2>

<p>函数的签名如下:</p>

<pre><code>func runtime.Caller(skip int) (pc uintptr, file string, line int, ok bool)
</code></pre>

<p><code>runtime.Caller</code> 返回当前 <code>goroutine</code> 的栈上的函数调用信息. 主要有当前的 <code>pc</code> 值和调用的文件和行号等信息. 若无法获得信息, 返回的 <code>ok</code> 值为 <code>false</code>.</p>

<p>其输入参数 <code>skip</code> 为要跳过的栈帧数, 若为 <code>0</code> 则表示 <code>runtime.Caller</code> 的调用者.</p>

<p><em>注意:由于历史原因, <code>runtime.Caller</code> 和 <code>runtime.Callers</code> 中的 <code>skip</code> 含义并不相同, 后面会讲到.</em></p>

<p>下面是一个简单的例子, 打印函数调用的栈帧信息:</p>

<pre><code>func main() {
    for skip := 0; ; skip++ {
        pc, file, line, ok := runtime.Caller(skip)
        if !ok {
            break
        }
        fmt.Printf(&quot;skip = %v, pc = %v, file = %v, line = %v\n&quot;, skip, pc, file, line)
    }
    // Output:
    // skip = 0, pc = 4198453, file = caller.go, line = 10
    // skip = 1, pc = 4280066, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 220
    // skip = 2, pc = 4289712, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
}
</code></pre>

<p>其中 <code>skip = 0</code> 为当前文件(&ldquo;caller.go&rdquo;)的 <code>main.main</code> 函数, 以及对应的行号. 这里省略的无关代码, 因此输出的行号和网页展示的位置有些差异.</p>

<p>另外的 <code>skip = 1</code> 和 <code>skip = 2</code> 也分别对应2个函数调用. 通过查阅 <code>runtime/proc.c</code> 文件的代码, 我们可以知道对应的函数分别为 <code>runtime.main</code> 和 <code>runtime.goexit</code>.</p>

<p>整理之后可以知道, Go的普通程序的启动顺序如下:</p>

<ol>
<li><code>runtime.goexit</code> 为真正的函数入口(并不是<code>main.main</code>)</li>
<li>然后 <code>runtime.goexit</code> 调用 <code>runtime.main</code> 函数</li>
<li>最终 <code>runtime.main</code> 调用用户编写的 <code>main.main</code> 函数</li>
</ol>

<h2 id="runtime-callers-的用法"><code>runtime.Callers</code> 的用法</h2>

<p>函数的签名如下:</p>

<pre><code>func runtime.Callers(skip int, pc []uintptr) int
</code></pre>

<p><code>runtime.Callers</code> 函数和 <code>runtime.Caller</code> 函数虽然名字相似(多一个后缀<code>s</code>), 但是函数的参数/返回值和参数的意义都有很大的差异.</p>

<p><code>runtime.Callers</code> 把调用它的函数Go程栈上的程序计数器填入切片 <code>pc</code> 中. 参数 <code>skip</code> 为开始在 pc 中记录之前所要跳过的栈帧数, <strong>若为0则表示 <code>runtime.Callers</code> 自身的栈帧, 若为1则表示调用者的栈帧</strong>. 该函数返回写入到 <code>pc</code> 切片中的项数(受切片的容量限制).</p>

<p>下面是 <code>runtime.Callers</code> 的例子, 用于输出每个栈帧的 <code>pc</code> 信息:</p>

<pre><code>func main() {
    pc := make([]uintptr, 1024)
    for skip := 0; ; skip++ {
        n := runtime.Callers(skip, pc)
        if n &lt;= 0 {
            break
        }
        fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])
    }
    // Output:
    // skip = 0, pc = [4304486 4198562 4280114 4289760]
    // skip = 1, pc = [4198562 4280114 4289760]
    // skip = 2, pc = [4280114 4289760]
    // skip = 3, pc = [4289760]
}
</code></pre>

<p>输出新的 <code>pc</code> 长度和 <code>skip</code> 大小有逆相关性. <code>skip = 0</code> 为 <code>runtime.Callers</code> 自身的信息.</p>

<p>这个例子比前一个例子多输出了一个栈帧, 就是因为多了一个<code>runtime.Callers</code>栈帧的信息(前一个例子是没有<code>runtime.Caller</code>信息的(<em>注意:没有<code>s</code>后缀</em>)).</p>

<p>那么 <code>runtime.Callers</code> 和 <code>runtime.Caller</code> 有哪些关联和差异?</p>

<h2 id="runtime-callers-和-runtime-caller-的异同"><code>runtime.Callers</code> 和 <code>runtime.Caller</code> 的异同</h2>

<p>因为前面2个例子为不同的程序, 输出的 <code>pc</code> 值并不具备参考性. 现在我们看看在同一个例子的输出结果如何:</p>

<pre><code>func main() {
    for skip := 0; ; skip++ {
        pc, file, line, ok := runtime.Caller(skip)
        if !ok {
            break
        }
        fmt.Printf(&quot;skip = %v, pc = %v, file = %v, line = %v\n&quot;, skip, pc, file, line)
    }
    // Output:
    // skip = 0, pc = 4198456, file = caller.go, line = 10
    // skip = 1, pc = 4280962, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 220
    // skip = 2, pc = 4290608, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
    pc := make([]uintptr, 1024)
    for skip := 0; ; skip++ {
        n := runtime.Callers(skip, pc)
        if n &lt;= 0 {
            break
        }
        fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])
    }
    // Output:
    // skip = 0, pc = [4305334 4198635 4280962 4290608]
    // skip = 1, pc = [4198635 4280962 4290608]
    // skip = 2, pc = [4280962 4290608]
    // skip = 3, pc = [4290608]
}
</code></pre>

<p>比如输出结果可以发现, <code>4280962</code> 和 <code>4290608</code> 两个 <code>pc</code> 值是相同的. 它们分别对应 <code>runtime.main</code> 和 <code>runtime.goexit</code> 函数.</p>

<p><code>runtime.Caller</code> 输出的 <code>4198456</code> 和 <code>runtime.Callers</code> 输出的 <code>4198635</code> 并不相同. 这是因为, 这两个函数的调用位置并不相同, 因此导致了 <code>pc</code> 值也不完全相同.</p>

<p>最后就是 <code>runtime.Callers</code> 多输出一个 <code>4305334</code> 值, 对应<code>runtime.Callers</code>内部的调用位置.</p>

<p>由于Go语言(Go1.2)采用分段堆栈, 因此不同的 <code>pc</code> 之间的大小关系并不明显.</p>

<h2 id="runtime-funcforpc-的用途"><code>runtime.FuncForPC</code> 的用途</h2>

<p>函数的签名如下:</p>

<pre><code>func runtime.FuncForPC(pc uintptr) *runtime.Func
func (f *runtime.Func) FileLine(pc uintptr) (file string, line int)
func (f *runtime.Func) Entry() uintptr
func (f *runtime.Func) Name() string
</code></pre>

<p>其中 <code>runtime.FuncForPC</code> 返回包含给定 <code>pc</code> 地址的函数, 如果是无效 <code>pc</code> 则返回 <code>nil</code> .</p>

<p><code>runtime.Func.FileLine</code> 返回与 <code>pc</code> 对应的源码文件名和行号. 安装文档的说明, 如果<code>pc</code>不在函数帧范围内, 则结果是不确定的.</p>

<p><code>runtime.Func.Entry</code> 对应函数的地址. <code>runtime.Func.Name</code> 返回该函数的名称.</p>

<p>下面是 <code>runtime.FuncForPC</code> 的例子:</p>

<pre><code>func main() {
    for skip := 0; ; skip++ {
        pc, _, _, ok := runtime.Caller(skip)
        if !ok {
            break
        }
        p := runtime.FuncForPC(pc)
        file, line := p.FileLine(0)

        fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc)
        fmt.Printf(&quot;  file = %v, line = %d\n&quot;, file, line)
        fmt.Printf(&quot;  entry = %v\n&quot;, p.Entry())
        fmt.Printf(&quot;  name = %v\n&quot;, p.Name())
    }
    // Output:
    // skip = 0, pc = 4198456
    //   file = caller.go, line = 8
    //   entry = 4198400
    //   name = main.main
    // skip = 1, pc = 4282882
    //   file = $(GOROOT)/src/pkg/runtime/proc.c, line = 179
    //   entry = 4282576
    //   name = runtime.main
    // skip = 2, pc = 4292528
    //   file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
    //   entry = 4292528
    //   name = runtime.goexit
    pc := make([]uintptr, 1024)
    for skip := 0; ; skip++ {
        n := runtime.Callers(skip, pc)
        if n &lt;= 0 {
            break
        }
        fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])
        for j := 0; j &lt; n; j++ {
            p := runtime.FuncForPC(pc[j])
            file, line := p.FileLine(0)

            fmt.Printf(&quot;  skip = %v, pc = %v\n&quot;, skip, pc[j])
            fmt.Printf(&quot;    file = %v, line = %d\n&quot;, file, line)
            fmt.Printf(&quot;    entry = %v\n&quot;, p.Entry())
            fmt.Printf(&quot;    name = %v\n&quot;, p.Name())
        }
        break
    }
    // Output:
    // skip = 0, pc = [4307254 4198586 4282882 4292528]
    //   skip = 0, pc = 4307254
    //     file = $(GOROOT)/src/pkg/runtime/runtime.c, line = 315
    //     entry = 4307168
    //     name = runtime.Callers
    //   skip = 0, pc = 4198586
    //     file = caller.go, line = 8
    //     entry = 4198400
    //     name = main.main
    //   skip = 0, pc = 4282882
    //     file = $(GOROOT)/src/pkg/runtime/proc.c, line = 179
    //     entry = 4282576
    //     name = runtime.main
    //   skip = 0, pc = 4292528
    //     file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
    //     entry = 4292528
    //     name = runtime.goexit
}
</code></pre>

<p>根据测试, 如果是无效 <code>pc</code> (比如<code>0</code>), <code>runtime.Func.FileLine</code> 一般会输出当前函数的开始行号. 不过在实践中, 一般会用 <code>runtime.Caller</code> 获取文件名和行号信息, <code>runtime.Func.FileLine</code> 很少用到(如何独立获取<code>pc</code>参数?).</p>

<h2 id="定制的-callername-函数">定制的 <code>CallerName</code> 函数</h2>

<p>基于前面的几个函数, 我们可以方便的定制一个 <code>CallerName</code> 函数. 函数 <code>CallerName</code> 返回调用者的函数名/文件名/行号等用户友好的信息.</p>

<p>函数实现如下:</p>

<pre><code>func CallerName(skip int) (name, file string, line int, ok bool) {
    var pc uintptr
    if pc, file, line, ok = runtime.Caller(skip + 1); !ok {
        return
    }
    name = runtime.FuncForPC(pc).Name()
    return
}
</code></pre>

<p>其中在执行 <code>runtime.Caller</code> 调用时, 参数 <code>skip + 1</code> 用于抵消 <code>CallerName</code> 函数自身的调用.</p>

<p>下面是基于 <code>CallerName</code> 的输出例子:</p>

<pre><code>func main() {
    for skip := 0; ; skip++ {
        name, file, line, ok := CallerName(skip)
        if !ok {
            break
        }
        fmt.Printf(&quot;skip = %v\n&quot;, skip)
        fmt.Printf(&quot;  file = %v, line = %d\n&quot;, file, line)
        fmt.Printf(&quot;  name = %v\n&quot;, name)
    }
    // Output:
    // skip = 0
    //   file = caller.go, line = 19
    //   name = main.main
    // skip = 1
    //   file = $(GOROOT)/src/pkg/runtime/proc.c, line = 220
    //   name = runtime.main
    // skip = 2
    //   file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
    //   name = runtime.goexit
}
</code></pre>

<p>这样就可以方便的输出函数调用者的信息了.</p>

<h2 id="go语言中函数的类型">Go语言中函数的类型</h2>

<p>在Go语言中, 除了语言定义的普通函数调用外, 还有闭包函数/init函数/全局变量初始化等不同的函数调用类型.</p>

<p>为了便于测试不同类型的函数调用, 我们包装一个 <code>PrintCallerName</code> 函数. 该函数用于输出调用者的信息.</p>

<pre><code>func PrintCallerName(skip int, comment string) bool {
    name, file, line, ok := CallerName(skip + 1)
    if !ok {
        return false
    }
    fmt.Printf(&quot;skip = %v, comment = %s\n&quot;, skip, comment)
    fmt.Printf(&quot;  file = %v, line = %d\n&quot;, file, line)
    fmt.Printf(&quot;  name = %v\n&quot;, name)
    return true
}
</code></pre>

<p>然后编写以下的测试代码(函数闭包调用/全局变量初始化/init函数等):</p>

<pre><code>var a = PrintCallerName(0, &quot;main.a&quot;)
var b = PrintCallerName(0, &quot;main.b&quot;)

func init() {
    a = PrintCallerName(0, &quot;main.init.a&quot;)
}

func init() {
    b = PrintCallerName(0, &quot;main.init.b&quot;)
    func() {
        b = PrintCallerName(0, &quot;main.init.b[1]&quot;)
    }()
}

func main() {
    a = PrintCallerName(0, &quot;main.main.a&quot;)
    b = PrintCallerName(0, &quot;main.main.b&quot;)
    func() {
        b = PrintCallerName(0, &quot;main.main.b[1]&quot;)
        func() {
            b = PrintCallerName(0, &quot;main.main.b[1][1]&quot;)
        }()
        b = PrintCallerName(0, &quot;main.main.b[2]&quot;)
    }()
}
</code></pre>

<p>输出结果如下:</p>

<pre><code>// Output:
// skip = 0, comment = main.a
//   file = caller.go, line = 8
//   name = main.init
// skip = 0, comment = main.b
//   file = caller.go, line = 9
//   name = main.init
// skip = 0, comment = main.init.a
//   file = caller.go, line = 12
//   name = main.init·1
// skip = 0, comment = main.init.b
//   file = caller.go, line = 16
//   name = main.init·2
// skip = 0, comment = main.init.b[1]
//   file = caller.go, line = 18
//   name = main.func·001
// skip = 0, comment = main.main.a
//   file = caller.go, line = 23
//   name = main.main
// skip = 0, comment = main.main.b
//   file = caller.go, line = 24
//   name = main.main
// skip = 0, comment = main.main.b[1]
//   file = caller.go, line = 26
//   name = main.func·003
// skip = 0, comment = main.main.b[1][1]
//   file = caller.go, line = 28
//   name = main.func·002
// skip = 0, comment = main.main.b[2]
//   file = caller.go, line = 30
//   name = main.func·003
</code></pre>

<p>观察输出结果, 可以发现以下几个规律:</p>

<ul>
<li>全局变量的初始化调用者为 <code>main.init</code> 函数</li>
<li>自定义的 <code>init</code> 函数有一个数字后缀, 根据出现的顺序进编号. 比如 <code>main.init·1</code> 和 <code>main.init·2</code> 等.</li>
<li>闭包函数采用 <code>main.func·001</code> 格式命名, 安装闭包定义结束的位置顺序进编号.</li>
</ul>

<p>比如以下全局变量的初始化调用者为 <code>main.init</code> 函数:</p>

<pre><code>var a = PrintCallerName(0, &quot;main.a&quot;)
var b = PrintCallerName(0, &quot;main.b&quot;)
</code></pre>

<p>以下两个 <code>init</code> 函数根据出现顺序分别对应 <code>main.init·1</code> 和 <code>main.init·2</code> :</p>

<pre><code>func init() { // main.init·1
    //
}
func init() { // main.init·2
    //
}
</code></pre>

<p>以下三个闭包根据定义结束顺序分别为 <code>001</code> / <code>002</code> / <code>003</code> :</p>

<pre><code>func init() {
    func(){
        //
    }() // main.func·001
}

func main() {
    func() {
        func(){
            //
        }() // main.func·002
    }() // main.func·003
}
</code></pre>

<p>因为, 这些特殊函数调用方式的存在, 我们需要进一步完善 <code>CallerName</code> 函数.</p>

<h2 id="改进的-callername-函数">改进的 <code>CallerName</code> 函数</h2>

<p>两类特殊的调用是 <code>init</code> 类函数调用 和 闭包函数调用.</p>

<p>改进后的 <code>CallerName</code> 函数对 <code>init</code> 类函数调用者统一处理为 <code>init</code> 函数. 将闭包函数调用这处理为调用者的函数名.</p>

<pre><code>// caller types:
// runtime.goexit
// runtime.main
// main.init
// main.init·1
// main.main
// main.func·001
// code.google.com/p/gettext-go/gettext.TestCallerName
// ...
func CallerName(skip int) (name, file string, line int, ok bool) {
    var (
        reInit    = regexp.MustCompile(`init·\d+$`) // main.init·1
        reClosure = regexp.MustCompile(`func·\d+$`) // main.func·001
    )
    for {
        var pc uintptr
        if pc, file, line, ok = runtime.Caller(skip + 1); !ok {
            return
        }
        name = runtime.FuncForPC(pc).Name()
        if reInit.MatchString(name) {
            name = reInit.ReplaceAllString(name, &quot;init&quot;)
            return
        }
        if reClosure.MatchString(name) {
            skip++
            continue
        }
        return
    }
    return
}
</code></pre>

<p>处理的思路:</p>

<ol>
<li>如果是 <code>init</code> 类型的函数调用(匹配正则表达式<code>&quot;init·\d+$&quot;</code>), 直接作为 <code>init</code> 函数范返回</li>
<li>如果是 <code>func</code> 闭包类型(匹配正则表达式<code>&quot;func·\d+$&quot;</code>), 跳过当前栈帧, 继续递归处理</li>
<li>返回普通的函数调用类型</li>
</ol>

<h2 id="callername-函数的不足之处"><code>CallerName</code> 函数的不足之处</h2>

<p>有以下的代码:</p>

<pre><code>func init() {
    var _ = myInit(&quot;1&quot;)
}
func main() {
    var _ = myInit(&quot;2&quot;)
}

var myInit = func(name string) {
    b = PrintCallerName(0, name + &quot;:main.myInit.b&quot;)
}
</code></pre>

<p><code>myInit</code> 为一个全局变量, 被赋值为一个闭包函数. 然后在 <code>init</code> 和 <code>main</code> 函数分别调用 <code>myInit</code> 这个闭包函数输出的结果
会因为调用环境的不同而有差异.</p>

<p>从直观上看, <code>myInit</code>闭包函数在执行时, 最好输出 <code>main.myInit</code> 函数名. 但是 <code>main.myInit</code> 只是一个绑定到闭包函数的变量, 而闭包的真正名字是 <code>main.func·???</code>. 在运行时是无法得到 <code>main.myInit</code> 这个名字的.</p>

<p>因此在 <a href="https://code.google.com/p/gettext-go/">gettext-go</a> 中内部用的 <code>callerName</code> 函数采用将 <code>main.func·???</code> 统一处理为 <code>main.func</code> 的, 然后作为 <code>gettext.Gettext</code> 翻译函数的上下文.</p>

<p><a href="https://code.google.com/p/gettext-go/">gettext-go</a> 的 <code>callerName</code> 函数实现在这里: <a href="https://code.google.com/p/gettext-go/source/browse/gettext/caller.go">caller.go</a>. 测试文件在这里: <a href="https://code.google.com/p/gettext-go/source/browse/gettext/caller_test.go">caller_test.go</a>.</p>

<h2 id="不同go程序启动流程">不同Go程序启动流程</h2>

<p>基于函数调用者信息可以很容易的验证各种环境的程序启动流程.</p>

<p>我们需要建立一个独立的 <code>caller</code> 目录, 里面有三个测试代码.</p>

<p><code>caller/main.go</code> 主程序:</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;regexp&quot;
    &quot;runtime&quot;
)

func main() {
    _ = PrintCallerName(0, &quot;main.main._&quot;)
}

func PrintCallerName(skip int, comment string) bool {
    // 实现和前面的例子相同
}

func CallerName(skip int) (name, file string, line int, ok bool) {
    // 实现和前面的例子相同
}
</code></pre>

<p><code>caller/main_test.go</code> 主程序的测试文件(同在一个<code>main</code>包):</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;testing&quot;
)

func TestPrintCallerName(t *testing.T) {
    for skip := 0; ; skip++ {
        name, file, line, ok := CallerName(skip)
        if !ok {
            break
        }
        fmt.Printf(&quot;skip = %v, name = %v, file = %v, line = %v\n&quot;, skip, name, file, line)
    }
    t.Fail()
}
</code></pre>

<p><code>caller/example_test.go</code> 主程序的包的调用者(在新的<code>main_test</code>包):</p>

<pre><code>package main_test

import (
    myMain &quot;.&quot;
    &quot;fmt&quot;
)

func Example() {
    for skip := 0; ; skip++ {
        name, file, line, ok := myMain.CallerName(skip)
        if !ok {
            break
        }
        fmt.Printf(&quot;skip = %v, name = %v, file = %v, line = %v\n&quot;, skip, name, file, line)
    }
    // Output: ?
}
</code></pre>

<p>然后进入 <code>caller</code> 目录, 运行 <code>go run test</code> 可以得到以下的输出结果:</p>

<pre><code>skip = 0, name = caller.TestPrintCallerName, file = caller/main_test.go, line = 10
skip = 1, name = testing.tRunner, file = $(GOROOT)/src/pkg/testing/testing.go, line = 391
skip = 2, name = runtime.goexit, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
--- FAIL: TestPrintCallerName (0.00 seconds)
--- FAIL: Example (2.0001ms)
got:
skip = 0, name = caller_test.Example, file = caller/example_test.go, line = 10

skip = 1, name = testing.runExample, file = $(GOROOT)/src/pkg/testing/example.go, line = 98
skip = 2, name = testing.RunExamples, file = $(GOROOT)/src/pkg/testing/example.go, line = 36
skip = 3, name = testing.Main, file = $(GOROOT)/src/pkg/testing/testing.go, line = 404
skip = 4, name = main.main, file = $(TEMP)/go-build365033523/caller/_test/_testmain.go, line = 51
skip = 5, name = runtime.main, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 220
skip = 6, name = runtime.goexit, file = $(GOROOT)/src/pkg/runtime/proc.c, line = 1394
want:
?
FAIL
exit status 1
FAIL    caller        0.254s
</code></pre>

<p>分析输出数据我们可以发现, 测试代码和例子代码的启动流程和普通的程序流程都不太一样.</p>

<p>测试代码的启动流程:</p>

<ol>
<li><code>runtime.goexit</code> 还是入口</li>
<li>但是 <code>runtime.goexit</code> 不在调用 <code>runtime.main</code> 函数, 而是调用 <code>testing.tRunner</code> 函数</li>
<li><code>testing.tRunner</code> 函数由 <code>go test</code> 命令生成, 用于执行各个测试函数</li>
</ol>

<p>例子代码的启动流程:</p>

<ol>
<li><code>runtime.goexit</code> 还是入口</li>
<li>然后 <code>runtime.goexit</code> 调用 <code>runtime.main</code> 函数</li>
<li>最终 <code>runtime.main</code> <strong>调用<code>go test</code> 命令生成的 <code>main.main</code> 函数</strong>, 在 <code>_test/_testmain.go</code> 文件</li>
<li>然后调用 <code>testing.Main</code>, 改函数执行各个例子函数</li>
</ol>

<p>另外, 从这个例子我们可以发现, 我们自己写的 <code>main.main</code> 函数所在的 <code>main</code> 包也可以被其他包导入. 但是其他包导入之后的 <code>main</code> 包里的 <code>main</code> 函数就不再是<code>main.main</code> 函数了. 因此, 程序的入口也就不是自己写的 <code>main.main</code> 函数了.</p>

<p><em>2015.06.09补充</em>:
更深入的可以看下这个文章 <a href="http://my.oschina.net/promi/blog/215035">GO语解惑：从源码分析GO程序的入口</a></p>

<h2 id="总结">总结</h2>

<p>Go语言 <code>runtime</code> 包的 <code>runtime.Caller</code> / <code>runtime.Callers</code> / <code>runtime.FuncForPC</code> 等函数虽然看起来比较简单, 但是功能却非常强大.</p>

<p>这几个函数不仅可以解决一些实际的工程问题(比如 <a href="https://code.google.com/p/gettext-go/">gettext-go</a> 中用于获取翻译的上下文信息), 而且非常适合用于调试和分析各种Go程序的运行时信息.</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">chai2010</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2014-01-04</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/golang/">golang</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/golang/go-gettext/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go语言的国际化支持(基于gettext-go)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/golang/go-zip-utf8/">
            <span class="next-text nav-default">Go如何处理zip中的中文文件名</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>

    <script src="https://giscus.app/client.js"
    data-repo="chai2010/chai2010.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjQxNjY5MDk="
    data-category="General"
    data-category-id="DIC_kwDOB2ai_c4CR3mk"
    data-mapping="og:title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  

  <span class="copyright-year">
    &copy;
    
      2006 -
    2023
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">chai2010</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>


</body>
</html>
