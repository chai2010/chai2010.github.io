<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>CvImage中的陷阱和BUG - chai2010 的博客</title>
  <link rel="alternate" hreflang="zh-CN" href="https://chai2010.cn/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="chai2010" />
  <meta name="description" content="CvImage类的定义 class CV_EXPORTS CvImage { public: CvImage() : image(0), refcount(0) {} CvImage( CvSize size, int depth, int channels ) { image = cvCreateImage( size, depth, channels ); refcount = image ? new int(1) : 0; } CvImage( IplImage* img ): image(img) { refcount = image ? new int(1) : 0; } ~CvImage() { if( refcount &amp;amp;&amp;amp; !(--*refcount) ) { cvReleaseImage(" />

  <meta name="keywords" content="chai2010, Go, Golang" />






<meta name="generator" content="Hugo 0.30.2" />


<link rel="canonical" href="https://chai2010.cn/post/2009/opencv-cvimage-bug/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">


<meta property="og:title" content="CvImage中的陷阱和BUG" />
<meta property="og:description" content="CvImage类的定义 class CV_EXPORTS CvImage { public: CvImage() : image(0), refcount(0) {} CvImage( CvSize size, int depth, int channels ) { image = cvCreateImage( size, depth, channels ); refcount = image ? new int(1) : 0; } CvImage( IplImage* img ): image(img) { refcount = image ? new int(1) : 0; } ~CvImage() { if( refcount &amp;&amp; !(--*refcount) ) { cvReleaseImage(" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chai2010.cn/post/2009/opencv-cvimage-bug/" />



<meta property="article:published_time" content="2009-12-06T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2009-12-06T00:00:00&#43;00:00"/>











<meta itemprop="name" content="CvImage中的陷阱和BUG">
<meta itemprop="description" content="CvImage类的定义 class CV_EXPORTS CvImage { public: CvImage() : image(0), refcount(0) {} CvImage( CvSize size, int depth, int channels ) { image = cvCreateImage( size, depth, channels ); refcount = image ? new int(1) : 0; } CvImage( IplImage* img ): image(img) { refcount = image ? new int(1) : 0; } ~CvImage() { if( refcount &amp;&amp; !(--*refcount) ) { cvReleaseImage(">


<meta itemprop="datePublished" content="2009-12-06T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2009-12-06T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2624">



<meta itemprop="keywords" content="opencv," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="CvImage中的陷阱和BUG"/>
<meta name="twitter:description" content="CvImage类的定义 class CV_EXPORTS CvImage { public: CvImage() : image(0), refcount(0) {} CvImage( CvSize size, int depth, int channels ) { image = cvCreateImage( size, depth, channels ); refcount = image ? new int(1) : 0; } CvImage( IplImage* img ): image(img) { refcount = image ? new int(1) : 0; } ~CvImage() { if( refcount &amp;&amp; !(--*refcount) ) { cvReleaseImage("/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-621845-14', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">chai2010 的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">全部文章</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/talks/">
        <li class="mobile-menu-item">报告</li>
      </a><a href="/books/">
        <li class="mobile-menu-item">图书</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">chai2010 的博客</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">全部文章</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/talks/">报告</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/books/">图书</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">CvImage中的陷阱和BUG</h1>

      <div class="post-meta">
        <span class="post-time"> 2009-12-06 </span>
        <div class="post-category">
            
              <a href="/categories/opencv/"> opencv </a>
            
          </div>
        <span class="more-meta"> 约 2624 字 </span>
        <span class="more-meta"> 预计阅读 6 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#cvimage类的定义">CvImage类的定义</a></li>
<li><a href="#关于引用计数">关于引用计数</a></li>
<li><a href="#cvimage中的引用计数机制">CvImage中的引用计数机制</a></li>
<li><a href="#cvimage-iplimage-img-陷阱"><code>CvImage(IplImage* img)</code> 陷阱</a></li>
<li><a href="#attach问题">attach问题</a></li>
<li><a href="#小节">小节</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h3 id="cvimage类的定义">CvImage类的定义</h3>

<pre><code>class CV_EXPORTS CvImage {
public:
    CvImage() : image(0), refcount(0) {}
    CvImage( CvSize size, int depth, int channels ) {
        image = cvCreateImage( size, depth, channels );
        refcount = image ? new int(1) : 0;
    }
    CvImage( IplImage* img ): image(img)  {
        refcount = image ? new int(1) : 0;
    }
    ~CvImage() {
        if( refcount &amp;&amp; !(--*refcount) ) {
            cvReleaseImage( &amp;image );
            delete refcount;
        }
    }
    void attach( IplImage* img, bool use_refcount=true ) {
        if( refcount ) {
            if( --*refcount == 0 ) cvReleaseImage( &amp;image );
            delete refcount;
        }
        image = img;
        refcount = use_refcount &amp;&amp; image ? new int(1) : 0;
    }
    void detach() {
        if( refcount ) {
            if( --*refcount == 0 )  cvReleaseImage( &amp;image );
            delete refcount;
            refcount = 0;
        }
        image = 0;
    }
    CvImage&amp; operator = (const CvImage&amp; img)   {
        if( img.refcount ) ++*img.refcount;
        if( refcount &amp;&amp; !(--*refcount) ) cvReleaseImage( &amp;image );
        image=img.image;
        refcount=img.refcount;
        return *this;
    }
protected:
    IplImage* image; // 实际影象
    int* refcount;   // 引用计数
};
</code></pre>

<p>CvImage类的相关代码在以下位置：
<code>OpenCV\cxcore\include\cxcore.hpp</code>/<code>OpenCV\cxcore\src\cximage.cpp</code>
这里给出的只是部分函数。</p>

<p>为了提高效率，<code>CvImage</code>采用的是引用计数。不过目前的<code>CvImage</code>实现中，引用计数机制存在bug。</p>

<h3 id="关于引用计数">关于引用计数</h3>

<p>引用计数应该也可以叫写时复制技术。就是在复制一个数据时，先只是简单地复制数据的 指针（地址），只有在数据被修改的时候才真的进行数据的复制操作。写时复制技术对用户 是透明的，也就是说用户可以当作数据是真的复制了。</p>

<p>一般数据（或者是文件，类等）都会对应创建/销毁操作。因此，采用写时复制技术的数据 一般还对应一个计数，记录该数据被别人引用的次数。数据在第一次被创建的时候被设置为1， 以后每次被重复创建则增加1，如果是被销毁则减少1。再销毁数据减少引用计数的时候，如果 记录变为0则真的执行删除数据操作，否则的话只执行逻辑删除。</p>

<p>这里需要注意的一点是，每个引用计数和它对应的数据是绑定的。因此，任何一个引用计数都 不应该独立于数据存在。</p>

<h3 id="cvimage中的引用计数机制">CvImage中的引用计数机制</h3>

<pre><code>class CV_EXPORTS CvImage {
    IplImage* image;
    int* refcount;
};
</code></pre>

<p><code>image</code>指向影像数据的地址，<code>refcount</code>指向影像数据对应的引用计数的地址。需要强调的一点是， <code>refcount</code>指向的引用计数并不属于哪个类，而是属于<code>image</code>指向影像数据！
任何将影像数据 和其对应的引用计数分离的操作都是错误的。</p>

<h3 id="cvimage-iplimage-img-陷阱"><code>CvImage(IplImage* img)</code> 陷阱</h3>

<p>假设有下面一个段代码：</p>

<pre><code>IplImage *pIplImg = cvLoadImage(&quot;load.tiff&quot;);  {
    CvImage cvImg(pIplImg);
}
cvSaveImage(&quot;save.tiff&quot;, pIplImg);
</code></pre>

<p>虽然逻辑上好像没有错误，但再执行到<code>cvSaveImage</code>语句的时候却会产生异常！跟踪调试后发现， 原来pIplImg对应的数据在cvImg析构的时候被释放了！</p>

<p>仔细分析后会发现，<code>CvImage</code>将<code>pIplImg</code>对应的数据和它本身的<code>refcount</code>绑定到一起了。<code>pIplImg</code> 对应的数据虽然不属于<code>CvImage</code>，但是它却依据<code>refcount</code>对其进行管理，直到<code>(*refcount)</code>变为0 的时候私自释放了<code>pIplImg</code>影像。</p>

<p>对于这个问题，我不建议使用引用计数，因此可以将代码修改为：</p>

<pre><code>CvImage( IplImage* img, bool use_refcount=false) : image(img)  {
    refcount = use_refcount &amp;&amp; image ? new int(1) : 0;
}
</code></pre>

<p>在默认的时候不使用引用计数机制，用户自己维护img内存空间。</p>

<h3 id="attach问题">attach问题</h3>

<pre><code>void attach( IplImage* img, bool use_refcount=true ) {
    if( refcount ) {
        if( --*refcount == 0 ) cvReleaseImage( &amp;image );
        delete refcount;
    }
    image = img;
    refcount = use_refcount &amp;&amp; image ? new int(1) : 0;
}
</code></pre>

<p><code>attach</code>是将一个<code>IplImage</code>影像绑定到<code>CvImage</code>。</p>

<p>其中的一个陷阱和前面的<code>CvImage</code>类似：</p>

<pre><code>IplImage *pIplImg = cvLoadImage(&quot;load.tiff&quot;);
{
    CvImage cvImg;
    cvImg.attach(pIplImg);
}  cvSaveImage(&quot;save.tiff&quot;, pIplImg); // 异常
</code></pre>

<p>处理是方法是把参数<code>use_refcount</code>的默认值改为<code>false</code>。</p>

<p>除了和<code>CvImage</code>类型的陷阱外，<code>attach</code>本身还有一个bug！</p>

<p>前面我们分析过，CvImage类中 <code>refcount</code>指向的空间和image指向的空间是绑在一起的。
因此，<code>if( --*refcount == 0 )</code> 语句中将<code>cvReleaseImage( &amp;image )</code>和<code>delete refcount</code>
分离的操作肯定是错误的！！</p>

<p>假设有以下代码：</p>

<pre><code>IplImage *pIplImg = cvLoadImage(&quot;load.tiff&quot;);
{
    CvImage cvImg;
    cvImg.create(cvSize(600,400), 8, 1); // 创建一个600*400的单字节单通道影像
    CvImage cvImgX(cvImg);               // 由cvImg拷贝构造cvImgX
    cvImgX.attach(pIplImg);
}
cvSaveImage(&quot;save.tiff&quot;, pIplImg);
</code></pre>

<p>代码将在执行完<code>cvImgX.attach(pIplImg)</code>语句后发生异常！</p>

<p>分析代码可以发现，<code>cvImg.create</code>先创建了一个影像，同时影像还对应一个引用计数。
由于<code>cvImgX</code> 是有<code>cvImg</code>拷贝构造得到，因此<code>cvImgX</code>也保存了和<code>cvImg</code>一样的<code>image</code>和<code>refcount</code>。
在接着执行的 <code>attach</code>中，<code>cvImgX</code>将<code>refcount</code>指向的空间释放（<code>delete refcount</code>）。
注意, <code>cvImgX</code>和<code>cvImg</code>的<code>refcount</code> 对应同一个空间！！</p>

<p>那么在，<code>cvImg</code>退出花括号执行析构函数的时候，<code>delete refcount</code>语句就非法了！</p>

<p>修改bug后的<code>attach</code>代码：</p>

<pre><code>void attach( IplImage* img, bool use_refcount=false ) // use_refcount默认值没有修改
{
    if( refcount )   {
        if( --*refcount == 0 ) { // 同时释放
            cvReleaseImage( &amp;image );
            delete refcount;
        }
    }
    image = img;
    refcount = use_refcount &amp;&amp; image ? new int(1) : 0;
}
</code></pre>

<p>由于CvImage中的许多函数都基于<code>attach</code>实现，因此没有修改use_refcount的默认值。
<code>detach</code>中的问题 和<code>attach</code>相似，代码修改如下：</p>

<pre><code>void detach() {
    if( refcount ) {
        if( --*refcount == 0 ) { // 同时释放
            cvReleaseImage( &amp;image );
            delete refcount;
        }
        refcount = 0;
    }
    image = 0;
}
</code></pre>

<p>重载操作符“=”时的内存泄漏</p>

<pre><code>CvImage&amp; operator = (const CvImage&amp; img)  {
    if( img.refcount ) ++*img.refcount;
    if( refcount &amp;&amp; !(--*refcount) ) cvReleaseImage( &amp;image );
    image=img.image;
    refcount=img.refcount;
    return *this;
}
</code></pre>

<p>假设有以下类似代码：</p>

<pre><code>CvImage cvImg1, cvImg2;
cvImg1.create(cvSize(600,400), 8, 1);
cvImg2.create(cvSize(800,500), 8, 1);
cvImg1 = cvImg2;
</code></pre>

<p>虽然看着很清晰，但是该代码却存在内存泄漏！分析如下：</p>

<p><code>cvImg1</code>先创建一个(600,400)大小的影像，默认还对应一个引用计数（<code>refcount</code>指向的空间）。
<code>cvImg2</code> 也采用同样的方式创建一个类似的影像。</p>

<p>注意：<code>cvImg1</code>和<code>cvImg1</code>中<code>refcount</code>指向的空间是不同的！！</p>

<p>下面执行“=”操作时，<code>cvImg1</code>的<code>image</code>空间被释放（<code>cvReleaseImage( &amp;image )</code>），
但是<code>cvImg1</code>的 <code>refcount</code>指向的空间却没有释放！
然后，<code>cvImg1</code>的<code>refcount</code>指向了<code>cvImg2</code>的<code>refcount</code>。
这样，<code>cvImg1</code> 的<code>refcount</code>指向内存就丢失了！</p>

<p>修改后的代码：</p>

<pre><code>CvImage&amp; operator = (const CvImage&amp; img)  {
    if( img.refcount ) ++*img.refcount;
    if( refcount &amp;&amp; !(--*refcount) ) {
        cvReleaseImage( &amp;image ); // 释放refcount
        delete refcount;
    }
    image=img.image;
    refcount=img.refcount;
    return *this;
}
</code></pre>

<h3 id="小节">小节</h3>

<p>虽然讲了这么多关于CvImage的陷阱和bug，单主要目的还是为了更好地使用CvImage。这里给出一个 建议：
在将IplImage数据和CvImage进行绑定，或者是基于IplImage数据构造CvImage对象的时候， 要清楚是否需要使用CvImage的引用计数技术（有哪些好处/坏处）。
特别是attach默认是采用引用计数的（没改的理由前面已经说明）。</p>

<p><strong>附：修复的<code>CvImage</code></strong></p>

<pre><code>class CV_EXPORTS CvImage  {
public:
    CvImage() : image(0), refcount(0) {}
    CvImage( CvSize size, int depth, int channels )
    {
        image = cvCreateImage( size, depth, channels );
        refcount = image ? new int(1) : 0;
    }
    // 修改
    CvImage( IplImage* img, bool use_refcount=false): image(img)
    {
        refcount = use_refcount &amp;&amp; image ? new int(1) : 0;
    }
    ~CvImage()
    {
        if( refcount &amp;&amp; !(--*refcount) ) {
            cvReleaseImage( &amp;image );
            delete refcount;
        }
    }
    // 修改
    void attach( IplImage* img, bool use_refcount=false ) // use_refcount默认值没有修改
    {
        if( refcount )    {
            if( --*refcount == 0 ) { // 同时释放
                cvReleaseImage( &amp;image );
                delete refcount;
            }
        }
        image = img;
        refcount = use_refcount &amp;&amp; image ? new int(1) : 0;
    }
    // 修改
    void detach()   {
        if( refcount )    {
            if( --*refcount == 0 ) { // 同时释放
                cvReleaseImage( &amp;image );
                delete refcount;
            }
            refcount = 0;
        }
        image = 0;
    }
    // 修改
    CvImage&amp; operator = (const CvImage&amp; img)   {
        if( img.refcount ) ++*img.refcount;
        if( refcount &amp;&amp; !(--*refcount) )    {
            cvReleaseImage( &amp;image );
            // 释放refcount
            delete refcount;
        }
        image=img.image;
        refcount=img.refcount;
        return *this;
    }
protected:
    IplImage* image; // 实际影象
    int* refcount;   // 引用计数
};
</code></pre>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">chai2010</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2009-12-06</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/opencv/">opencv</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/2009/link-list-reverse/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">单向链表的逆序</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/2009/opencv-memory-leak-test/">
            <span class="next-text nav-default">OpenCV中的内存泄漏检测</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>

    <script src="https://giscus.app/client.js"
    data-repo="chai2010/chai2010.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjQxNjY5MDk="
    data-category="General"
    data-category-id="DIC_kwDOB2ai_c4CR3mk"
    data-mapping="og:title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
</div>

<div class="copyright">
  

  <span class="copyright-year">
    &copy;
    
      2006 -
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">chai2010</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>


</body>
</html>
