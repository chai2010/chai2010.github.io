<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>链表 on chai2010 的博客</title>
    <link>https://chai2010.cn/tags/%E9%93%BE%E8%A1%A8/</link>
    <description>Recent content in 链表 on chai2010 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 07 Dec 2009 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://chai2010.cn/tags/%E9%93%BE%E8%A1%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>单向链表的逆序</title>
      <link>https://chai2010.cn/post/2009/link-list-reverse/</link>
      <pubDate>Mon, 07 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>https://chai2010.cn/post/2009/link-list-reverse/</guid>
      
        <description>&lt;p&gt;假设链表的结构为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Node { int item; Node* next; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单向链表是一个有序的序列.假设有一个单向链表A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1, 2, 3, 4, 5, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在将A表逆序后得到链表B:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;..., 5, 4, 3, 2, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常规的反转链表方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node *reverse(Node *list)
{
    link t, y = list, r = 0;
    while (y != 0) { t = y-&amp;gt;next; y-&amp;gt;next = r; r = y; y = t; }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实上面的这个操作自然地对应于栈的出栈/压栈操作.
因此, 单向链表的逆序问题我们也可以抽象为A和B两个栈的转换问题.&lt;/p&gt;

&lt;p&gt;现在给Node实现用于栈的操作函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 1. 判断栈是否为空
bool isEmpty(Node* stack)
{
    return (stack == NULL);
}

// 2. 向栈stack中压入一个node元素
void push(Node* &amp;amp;stack, Node* node)
{
    node-&amp;gt;next = stack;
    stack = node;
}

// 3. 从栈stack中弹出一个元素
Node* pop(Node* &amp;amp;stack)
{
    assert(!isEmpty(stack));

    Node *t = stack;
    stack = stack-&amp;gt;next;

    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面可以基于栈实现单向链表的逆序操作了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node *reverse(Node *oldList)
{
    Node *newList = NULL;

    while(!isEmpty(oldList))
    {
        push(newList, pop(oldList));
    }

    return newList;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用栈的思维来思考单向链表的逆序问题之后,许多本来相对复杂的问题都会变得异常简单.
例如, 我们现在再考虑用递归的方法来逆序链表.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 递归实现反转链表
Node *reverse(Node *oldList, Node *newList=NULL)
{
    // 判断oldList是否为空
    if(isEmpty(oldList)) return newList;

    // 从oldList栈弹出一个元素
    // 然后将弹出的元素压到newList栈中
    push(newList, pop(oldList));

    // 递归处理剩下的oldList链表
    return reverse(oldList, newList);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归版本的调用方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main()
{
    Node *list = NULL;

    // newList采用默认的NULL
    Node *t = reverse(list);

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>怎样判断链表有没有环</title>
      <link>https://chai2010.cn/post/2009/link-list-ring-test/</link>
      <pubDate>Sat, 05 Dec 2009 00:00:00 +0000</pubDate>
      
      <guid>https://chai2010.cn/post/2009/link-list-ring-test/</guid>
      
        <description>&lt;p&gt;假设序列&lt;code&gt;X0, X1, X2, ...&lt;/code&gt;是由&lt;code&gt;X(n+1) = f(Xn)&lt;/code&gt;定义的, 如果f的值域是有限,
那么序列必定是循环的.
也就是说，这个序列包含一个前导（前缀）序列: &lt;code&gt;X0, X1, ... X(u-1)&lt;/code&gt;,
后面跟着一个不受限制的循环: &lt;code&gt;Xu, X(u+1), ..., X(u+t-1)&lt;/code&gt;, 其中t是循环的周期.&lt;/p&gt;

&lt;p&gt;这个结论可以由抽屉原理推导出来:
即N+1个苹果放在N个屉子里, 至少有一个屉子至少有2个或以上的苹果.
对于&lt;code&gt;X(n+1) = f(Xn)&lt;/code&gt;来说, 如果&lt;code&gt;Xn&lt;/code&gt;和&lt;code&gt;X(n+t-1)&lt;/code&gt;是相同的, 那么它们的后继也就是相同的,
也就是出现环了.&lt;/p&gt;

&lt;p&gt;在随机数的生成以及检测连表的循环方面，都是相同的问题。&lt;/p&gt;

&lt;p&gt;对于单连表而言，可以定义函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int f(int x)
{
    return (x)? ((Node*)x)-&amp;gt;next: head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即，假设连表到尾部之后再调用f就从头开始,
这样我们测试f的循环周期, 如果周期比连表
长度短肯定是是有内部循环.&lt;/p&gt;

&lt;p&gt;R.W.Floyd算法可以描述为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = f(x)
y = f(f(y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;xy&lt;/code&gt;被初始化为&lt;code&gt;X0&lt;/code&gt;。经过n步之后，&lt;code&gt;x = Xn, y = X2n&lt;/code&gt;。
比较这些元素，如果相等，那么就知道Xn和X2n之间的间隔
是周期&lt;code&gt;t&lt;/code&gt;的整数倍，即&lt;code&gt;2n-n=n&lt;/code&gt;是&lt;code&gt;t&lt;/code&gt;的倍数。&lt;/p&gt;

&lt;p&gt;于是&lt;code&gt;u&lt;/code&gt;就可以通过重新生成序列并比较&lt;code&gt;X0&lt;/code&gt;和&lt;code&gt;Xn&lt;/code&gt;, &lt;code&gt;X1&lt;/code&gt;和&lt;code&gt;X(n+1)&lt;/code&gt;, 等等来确定.
当&lt;code&gt;Xu&lt;/code&gt;和&lt;code&gt;X(u+n)&lt;/code&gt;相比较相等的情况.&lt;/p&gt;

&lt;p&gt;最后, 通过重新生成更多的元素并把&lt;code&gt;Xu&lt;/code&gt;和&lt;code&gt;X(u+1)&lt;/code&gt;, &lt;code&gt;X(u+2)&lt;/code&gt;, &amp;hellip;
相比较来确定周期t.&lt;/p&gt;

&lt;p&gt;这个算法仅需要较小且有界的空间, 但是它要多次计算f。&lt;/p&gt;

&lt;p&gt;Gosper的算法寻找f的周期t, 但不求第一次循环开始点u.
他的主要特征是从不回头去重新计算f, 而且在空间和时间上相当经济.&lt;/p&gt;

&lt;p&gt;它所用的空间是无界的: 它需要一个长度为&lt;code&gt;log2(max(t))+1&lt;/code&gt;的表,
其中max(t)是最大可能的周期. 这不会需要太多的空间.&lt;/p&gt;

&lt;p&gt;例如: 如果是针对32位二进制, 那么33个字就足够了.&lt;/p&gt;

&lt;p&gt;Gosper算法的C实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void ld_Gosper(int (*f)(int), int X0,
            int *mu_l,int *mu_u, int *lambda)
{
    int Xn, k, m, kmax, n, lgl;
    int T[33];

    T[0] = X0;
    Xn = X0;
    for (n = 1; ; n++) {
        Xn = f(Xn);
        kmax = 31 - nlz(n);           // Floor(log2 n).
        for (k = 0; k &amp;lt;= kmax; k++) {
            if (Xn == T[k]) goto L;
        }
        T[ntz(n+1)] = Xn;             // No match.
    }

L:
    // Compute m = max{i | i &amp;lt; n and ntz(i+1) = k}.

    m = ((((n &amp;gt;&amp;gt; k) - 1) | 1) &amp;lt;&amp;lt; k) - 1;
    *lambda = n - m;
    lgl = 31 - nlz(*lambda - 1); // Ceil(log2 lambda) - 1.
    *mu_u = m;                       // Upper bound on mu.
    *mu_l = m - max(1, 1 &amp;lt;&amp;lt; lgl) + 1;// Lower bound on mu.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数以需要分析的函数f和初始值X0为参数。它返回u的上界
和下界以及周期t（尽管Gosper算法不能计算u，但它能计算u的
上界和下界）。&lt;/p&gt;

&lt;p&gt;函数中还用到了3个子函数：&lt;code&gt;nlz&lt;/code&gt;, &lt;code&gt;ntz&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;nlz&lt;/code&gt;是求二进制前缀0的数目，&lt;code&gt;ntz&lt;/code&gt;是计算二进制后缀0的数目，
&lt;code&gt;max&lt;/code&gt;求最大值（不用详细描述）。下面给出&lt;code&gt;nlz&lt;/code&gt;和&lt;code&gt;ntz&lt;/code&gt;的实现代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int nlz(unsigned x)
{
    int n;

    if (x == 0) return(32);
    n = 1;
    if ((x &amp;gt;&amp;gt; 16) == 0) {n = n +16; x = x &amp;lt;&amp;lt;16;}
    if ((x &amp;gt;&amp;gt; 24) == 0) {n = n + 8; x = x &amp;lt;&amp;lt; 8;}
    if ((x &amp;gt;&amp;gt; 28) == 0) {n = n + 4; x = x &amp;lt;&amp;lt; 4;}
    if ((x &amp;gt;&amp;gt; 30) == 0) {n = n + 2; x = x &amp;lt;&amp;lt; 2;}
    n = n - (x &amp;gt;&amp;gt; 31);
    return n;
}

int ntz(unsigned x)
{
    int n;

    x = ~x &amp;amp; (x - 1);
    n = 0;                       // n = 32;
    while(x != 0) {              // while (x != 0) {
        n = n + 1;                //    n = n - 1;
        x = x &amp;gt;&amp;gt; 1;               //    x = x + x;
    }                            // }
    return n;                    // return n;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中计算后缀0数目的函数&lt;code&gt;ntz&lt;/code&gt;有的地方也叫标尺函数，
因为通过它给出了标尺上的二等份、四等份、&amp;hellip;&lt;/p&gt;

&lt;p&gt;标尺函数可以揭示出如何解汉诺塔之谜。标尺函数
还可以用于生成反射二进制Gray编码。&lt;/p&gt;

&lt;p&gt;关于Gosper的讨论可以参考Knuth, Donald E的经典著作：
《计算机程序设计的艺术》卷2，3.1节的习题7。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>